import { SET_TYPE, FETCH_TYPE, RESET_TYPE } from '../actionTypes.js';
import Controller from '../controller/Controller.js';
import createSet from '../controller/createSet.js';
import RIC from '../state/RIC.js';
export class ResetError extends Error {
  constructor() {
    super('Aborted due to RESET');
    this.name = 'ResetError';
  }
}

/** Handles all async network dispatches
 *
 * Dedupes concurrent requests by keeping track of all fetches in flight
 * and returning existing promises for requests already in flight.
 *
 * Interfaces with store via a redux-compatible middleware.
 *
 * @see https://dataclient.io/docs/api/NetworkManager
 */
export default class NetworkManager {
  constructor(dataExpiryLength = 60000, errorExpiryLength = 1000) {
    this.fetched = Object.create(null);
    this.resolvers = {};
    this.rejectors = {};
    this.fetchedAt = {};
    this.controller = new Controller();
    this.dataExpiryLength = dataExpiryLength;
    this.errorExpiryLength = errorExpiryLength;
    this.middleware = controller => {
      this.controller = controller;
      return next => action => {
        switch (action.type) {
          case FETCH_TYPE:
            this.handleFetch(action);
            // This is the only case that causes any state change
            // It's important to intercept other fetches as we don't want to trigger reducers during
            // render - so we need to stop 'readonly' fetches which can be triggered in render
            if (action.endpoint.getOptimisticResponse !== undefined && action.endpoint.sideEffect) {
              return next(action);
            }
            return Promise.resolve();
          case SET_TYPE:
            // only receive after new state is computed
            return next(action).then(() => {
              if (action.meta.key in this.fetched) {
                var _controller$getState$;
                // Note: meta *must* be set by reducer so this should be safe
                const error = (_controller$getState$ = controller.getState().meta[action.meta.key]) == null ? void 0 : _controller$getState$.error;
                // processing errors result in state meta having error, so we should reject the promise
                if (error) {
                  this.handleReceive(createSet(action.endpoint, {
                    args: action.meta.args,
                    response: error,
                    fetchedAt: action.meta.fetchedAt,
                    error: true
                  }));
                } else {
                  this.handleReceive(action);
                }
              }
            });
          case RESET_TYPE:
            {
              const rejectors = Object.assign({}, this.rejectors);
              this.clearAll();
              return next(action).then(() => {
                // there could be external listeners to the promise
                // this must happen after commit so our own rejector knows not to dispatch an error based on this
                for (const k in rejectors) {
                  rejectors[k](new ResetError());
                }
              });
            }
          default:
            return next(action);
        }
      };
    };
  }

  /** Used by DevtoolsManager to determine whether to log an action */
  skipLogging(action) {
    /* istanbul ignore next */
    return action.type === FETCH_TYPE && action.meta.key in this.fetched;
  }

  /** On mount */
  init() {
    delete this.cleanupDate;
  }

  /** Ensures all promises are completed by rejecting remaining. */
  cleanup() {
    // ensure no dispatches after unmount
    // this must be reversible (done in init) so useEffect() remains symmetric
    this.cleanupDate = Date.now();
  }
  allSettled() {
    const fetches = Object.values(this.fetched);
    if (fetches.length) return Promise.allSettled(fetches);
  }

  /** Clear all promise state */
  clearAll() {
    for (const k in this.rejectors) {
      this.clear(k);
    }
  }

  /** Clear promise state for a given key */
  clear(key) {
    this.fetched[key].catch(() => {});
    delete this.resolvers[key];
    delete this.rejectors[key];
    delete this.fetched[key];
    delete this.fetchedAt[key];
  }
  getLastReset() {
    if (this.cleanupDate) return this.cleanupDate;
    return this.controller.getState().lastReset;
  }

  /** Called when middleware intercepts 'rest-hooks/fetch' action.
   *
   * Will then start a promise for a key and potentially start the network
   * fetch.
   *
   * Uses throttle only when instructed by action meta. This is valuable
   * for ensures mutation requests always go through.
   */
  handleFetch(action) {
    const fetch = action.payload;
    const {
      key,
      throttle,
      resolve,
      reject,
      createdAt
    } = action.meta;
    const deferedFetch = () => {
      let promise = fetch();
      const resolvePromise = promise => promise.then(data => {
        resolve(data);
        return data;
      }).catch(error => {
        reject(error);
        throw error;
      });
      // schedule non-throttled resolutions in a microtask before receive
      // this enables users awaiting their fetch to trigger any react updates needed to deal
      // with upcoming changes because of the fetch (for instance avoiding suspense if something is deleted)
      if (!throttle) {
        promise = resolvePromise(promise);
      }
      promise = promise.then(data => {
        let lastReset = this.getLastReset();

        /* istanbul ignore else */
        if (process.env.NODE_ENV !== 'production' && isNaN(lastReset)) {
          console.error('state.lastReset is NaN. Only positive timestamps are valid.');
          lastReset = 0;
        }

        // don't update state with promises started before last clear
        if (createdAt >= lastReset) {
          this.controller.resolve(action.endpoint, {
            args: action.meta.args,
            response: data,
            fetchedAt: createdAt
          });
        }
        return data;
      }).catch(error => {
        const lastReset = this.getLastReset();
        // don't update state with promises started before last clear
        if (createdAt >= lastReset) {
          this.controller.resolve(action.endpoint, {
            args: action.meta.args,
            response: error,
            fetchedAt: createdAt,
            error: true
          });
        }
        throw error;
      });
      return promise;
    };
    if (throttle) {
      return this.throttle(key, deferedFetch, createdAt).then(data => resolve(data)).catch(error => reject(error));
    } else {
      return deferedFetch().catch(() => {});
    }
  }

  /** Called when middleware intercepts a receive action.
   *
   * Will resolve the promise associated with receive key.
   */
  handleReceive(action) {
    // this can still turn out to be untrue since this is async
    if (action.meta.key in this.fetched) {
      let promiseHandler;
      if (action.error) {
        promiseHandler = this.rejectors[action.meta.key];
      } else {
        promiseHandler = this.resolvers[action.meta.key];
      }
      promiseHandler(action.payload);
      // since we're resolved we no longer need to keep track of this promise
      this.clear(action.meta.key);
    }
  }

  /** Attaches NetworkManager to store
   *
   * Intercepts 'rest-hooks/fetch' actions to start requests.
   *
   * Resolve/rejects a request when matching 'rest-hooks/receive' event
   * is seen.
   */
  getMiddleware() {
    return this.middleware;
  }

  /** Ensures only one request for a given key is in flight at any time
   *
   * Uses key to either retrieve in-flight promise, or if not
   * create a new promise and call fetch.
   *
   * Note: The new promise is not actually tied to fetch at all,
   * but is resolved when the expected 'recieve' action is processed.
   * This ensures promises are resolved only once their data is processed
   * by the reducer.
   */
  throttle(key, fetch, createdAt) {
    const lastReset = this.getLastReset();
    // we're already fetching so reuse the promise
    // fetches after reset do not count
    if (key in this.fetched && this.fetchedAt[key] > lastReset) {
      return this.fetched[key];
    }
    this.fetched[key] = new Promise((resolve, reject) => {
      this.resolvers[key] = resolve;
      this.rejectors[key] = reject;
    });
    this.fetchedAt[key] = createdAt;

    // since our real promise is resolved via the wrapReducer(),
    // we should just stop all errors here.
    // TODO: decouple this from useFetcher() (that's what's dispatching the error the resolves in here)
    RIC(() => {
      fetch().catch(() => null);
    }, {
      timeout: 500
    });
    return this.fetched[key];
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTRVRfVFlQRSIsIkZFVENIX1RZUEUiLCJSRVNFVF9UWVBFIiwiQ29udHJvbGxlciIsImNyZWF0ZVNldCIsIlJJQyIsIlJlc2V0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibmFtZSIsIk5ldHdvcmtNYW5hZ2VyIiwiZGF0YUV4cGlyeUxlbmd0aCIsImVycm9yRXhwaXJ5TGVuZ3RoIiwiZmV0Y2hlZCIsIk9iamVjdCIsImNyZWF0ZSIsInJlc29sdmVycyIsInJlamVjdG9ycyIsImZldGNoZWRBdCIsImNvbnRyb2xsZXIiLCJtaWRkbGV3YXJlIiwibmV4dCIsImFjdGlvbiIsInR5cGUiLCJoYW5kbGVGZXRjaCIsImVuZHBvaW50IiwiZ2V0T3B0aW1pc3RpY1Jlc3BvbnNlIiwidW5kZWZpbmVkIiwic2lkZUVmZmVjdCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIm1ldGEiLCJrZXkiLCJfY29udHJvbGxlciRnZXRTdGF0ZSQiLCJlcnJvciIsImdldFN0YXRlIiwiaGFuZGxlUmVjZWl2ZSIsImFyZ3MiLCJyZXNwb25zZSIsImFzc2lnbiIsImNsZWFyQWxsIiwiayIsInNraXBMb2dnaW5nIiwiaW5pdCIsImNsZWFudXBEYXRlIiwiY2xlYW51cCIsIkRhdGUiLCJub3ciLCJhbGxTZXR0bGVkIiwiZmV0Y2hlcyIsInZhbHVlcyIsImxlbmd0aCIsImNsZWFyIiwiY2F0Y2giLCJnZXRMYXN0UmVzZXQiLCJsYXN0UmVzZXQiLCJmZXRjaCIsInBheWxvYWQiLCJ0aHJvdHRsZSIsInJlamVjdCIsImNyZWF0ZWRBdCIsImRlZmVyZWRGZXRjaCIsInByb21pc2UiLCJyZXNvbHZlUHJvbWlzZSIsImRhdGEiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJpc05hTiIsImNvbnNvbGUiLCJwcm9taXNlSGFuZGxlciIsImdldE1pZGRsZXdhcmUiLCJ0aW1lb3V0Il0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL21hbmFnZXIvTmV0d29ya01hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0VUX1RZUEUsIEZFVENIX1RZUEUsIFJFU0VUX1RZUEUgfSBmcm9tICcuLi9hY3Rpb25UeXBlcy5qcyc7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tICcuLi9jb250cm9sbGVyL0NvbnRyb2xsZXIuanMnO1xuaW1wb3J0IGNyZWF0ZVNldCBmcm9tICcuLi9jb250cm9sbGVyL2NyZWF0ZVNldC5qcyc7XG5pbXBvcnQgUklDIGZyb20gJy4uL3N0YXRlL1JJQy5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIEZldGNoQWN0aW9uLFxuICBNYW5hZ2VyLFxuICBBY3Rpb25UeXBlcyxcbiAgTWlkZGxld2FyZUFQSSxcbiAgTWlkZGxld2FyZSxcbiAgU2V0QWN0aW9uLFxufSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBSZXNldEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lID0gJ1Jlc2V0RXJyb3InO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdBYm9ydGVkIGR1ZSB0byBSRVNFVCcpO1xuICB9XG59XG5cbi8qKiBIYW5kbGVzIGFsbCBhc3luYyBuZXR3b3JrIGRpc3BhdGNoZXNcbiAqXG4gKiBEZWR1cGVzIGNvbmN1cnJlbnQgcmVxdWVzdHMgYnkga2VlcGluZyB0cmFjayBvZiBhbGwgZmV0Y2hlcyBpbiBmbGlnaHRcbiAqIGFuZCByZXR1cm5pbmcgZXhpc3RpbmcgcHJvbWlzZXMgZm9yIHJlcXVlc3RzIGFscmVhZHkgaW4gZmxpZ2h0LlxuICpcbiAqIEludGVyZmFjZXMgd2l0aCBzdG9yZSB2aWEgYSByZWR1eC1jb21wYXRpYmxlIG1pZGRsZXdhcmUuXG4gKlxuICogQHNlZSBodHRwczovL2RhdGFjbGllbnQuaW8vZG9jcy9hcGkvTmV0d29ya01hbmFnZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV0d29ya01hbmFnZXIgaW1wbGVtZW50cyBNYW5hZ2VyIHtcbiAgcHJvdGVjdGVkIGZldGNoZWQ6IHsgW2s6IHN0cmluZ106IFByb21pc2U8YW55PiB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcHJvdGVjdGVkIHJlc29sdmVyczogeyBbazogc3RyaW5nXTogKHZhbHVlPzogYW55KSA9PiB2b2lkIH0gPSB7fTtcbiAgcHJvdGVjdGVkIHJlamVjdG9yczogeyBbazogc3RyaW5nXTogKHZhbHVlPzogYW55KSA9PiB2b2lkIH0gPSB7fTtcbiAgcHJvdGVjdGVkIGZldGNoZWRBdDogeyBbazogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcbiAgZGVjbGFyZSByZWFkb25seSBkYXRhRXhwaXJ5TGVuZ3RoOiBudW1iZXI7XG4gIGRlY2xhcmUgcmVhZG9ubHkgZXJyb3JFeHBpcnlMZW5ndGg6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGRlY2xhcmUgbWlkZGxld2FyZTogTWlkZGxld2FyZTtcbiAgcHJvdGVjdGVkIGNvbnRyb2xsZXI6IENvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcigpO1xuICBkZWNsYXJlIGNsZWFudXBEYXRlPzogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGFFeHBpcnlMZW5ndGggPSA2MDAwMCwgZXJyb3JFeHBpcnlMZW5ndGggPSAxMDAwKSB7XG4gICAgdGhpcy5kYXRhRXhwaXJ5TGVuZ3RoID0gZGF0YUV4cGlyeUxlbmd0aDtcbiAgICB0aGlzLmVycm9yRXhwaXJ5TGVuZ3RoID0gZXJyb3JFeHBpcnlMZW5ndGg7XG5cbiAgICB0aGlzLm1pZGRsZXdhcmUgPSA8QyBleHRlbmRzIE1pZGRsZXdhcmVBUEk+KGNvbnRyb2xsZXI6IEMpID0+IHtcbiAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gKG5leHQ6IENbJ2Rpc3BhdGNoJ10pOiBDWydkaXNwYXRjaCddID0+XG4gICAgICAgIChhY3Rpb24pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEZFVENIX1RZUEU6XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlRmV0Y2goYWN0aW9uKTtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBjYXNlIHRoYXQgY2F1c2VzIGFueSBzdGF0ZSBjaGFuZ2VcbiAgICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gaW50ZXJjZXB0IG90aGVyIGZldGNoZXMgYXMgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIHJlZHVjZXJzIGR1cmluZ1xuICAgICAgICAgICAgICAvLyByZW5kZXIgLSBzbyB3ZSBuZWVkIHRvIHN0b3AgJ3JlYWRvbmx5JyBmZXRjaGVzIHdoaWNoIGNhbiBiZSB0cmlnZ2VyZWQgaW4gcmVuZGVyXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBhY3Rpb24uZW5kcG9pbnQuZ2V0T3B0aW1pc3RpY1Jlc3BvbnNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBhY3Rpb24uZW5kcG9pbnQuc2lkZUVmZmVjdFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIGNhc2UgU0VUX1RZUEU6XG4gICAgICAgICAgICAgIC8vIG9ubHkgcmVjZWl2ZSBhZnRlciBuZXcgc3RhdGUgaXMgY29tcHV0ZWRcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLm1ldGEua2V5IGluIHRoaXMuZmV0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgLy8gTm90ZTogbWV0YSAqbXVzdCogYmUgc2V0IGJ5IHJlZHVjZXIgc28gdGhpcyBzaG91bGQgYmUgc2FmZVxuICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPVxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmdldFN0YXRlKCkubWV0YVthY3Rpb24ubWV0YS5rZXldPy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3NpbmcgZXJyb3JzIHJlc3VsdCBpbiBzdGF0ZSBtZXRhIGhhdmluZyBlcnJvciwgc28gd2Ugc2hvdWxkIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVjZWl2ZShcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVTZXQoYWN0aW9uLmVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBhY3Rpb24ubWV0YS5hcmdzIGFzIGFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZWRBdDogYWN0aW9uLm1ldGEuZmV0Y2hlZEF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlY2VpdmUoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBSRVNFVF9UWVBFOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlamVjdG9ycyA9IHsgLi4udGhpcy5yZWplY3RvcnMgfTtcblxuICAgICAgICAgICAgICB0aGlzLmNsZWFyQWxsKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbikudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgY291bGQgYmUgZXh0ZXJuYWwgbGlzdGVuZXJzIHRvIHRoZSBwcm9taXNlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBtdXN0IGhhcHBlbiBhZnRlciBjb21taXQgc28gb3VyIG93biByZWplY3RvciBrbm93cyBub3QgdG8gZGlzcGF0Y2ggYW4gZXJyb3IgYmFzZWQgb24gdGhpc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiByZWplY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdG9yc1trXShuZXcgUmVzZXRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBVc2VkIGJ5IERldnRvb2xzTWFuYWdlciB0byBkZXRlcm1pbmUgd2hldGhlciB0byBsb2cgYW4gYWN0aW9uICovXG4gIHNraXBMb2dnaW5nKGFjdGlvbjogQWN0aW9uVHlwZXMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBhY3Rpb24udHlwZSA9PT0gRkVUQ0hfVFlQRSAmJiBhY3Rpb24ubWV0YS5rZXkgaW4gdGhpcy5mZXRjaGVkO1xuICB9XG5cbiAgLyoqIE9uIG1vdW50ICovXG4gIGluaXQoKSB7XG4gICAgZGVsZXRlIHRoaXMuY2xlYW51cERhdGU7XG4gIH1cblxuICAvKiogRW5zdXJlcyBhbGwgcHJvbWlzZXMgYXJlIGNvbXBsZXRlZCBieSByZWplY3RpbmcgcmVtYWluaW5nLiAqL1xuICBjbGVhbnVwKCkge1xuICAgIC8vIGVuc3VyZSBubyBkaXNwYXRjaGVzIGFmdGVyIHVubW91bnRcbiAgICAvLyB0aGlzIG11c3QgYmUgcmV2ZXJzaWJsZSAoZG9uZSBpbiBpbml0KSBzbyB1c2VFZmZlY3QoKSByZW1haW5zIHN5bW1ldHJpY1xuICAgIHRoaXMuY2xlYW51cERhdGUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgYWxsU2V0dGxlZCgpIHtcbiAgICBjb25zdCBmZXRjaGVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLmZldGNoZWQpO1xuICAgIGlmIChmZXRjaGVzLmxlbmd0aCkgcmV0dXJuIFByb21pc2UuYWxsU2V0dGxlZChmZXRjaGVzKTtcbiAgfVxuXG4gIC8qKiBDbGVhciBhbGwgcHJvbWlzZSBzdGF0ZSAqL1xuICBwcm90ZWN0ZWQgY2xlYXJBbGwoKSB7XG4gICAgZm9yIChjb25zdCBrIGluIHRoaXMucmVqZWN0b3JzKSB7XG4gICAgICB0aGlzLmNsZWFyKGspO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDbGVhciBwcm9taXNlIHN0YXRlIGZvciBhIGdpdmVuIGtleSAqL1xuICBwcm90ZWN0ZWQgY2xlYXIoa2V5OiBzdHJpbmcpIHtcbiAgICB0aGlzLmZldGNoZWRba2V5XS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgZGVsZXRlIHRoaXMucmVzb2x2ZXJzW2tleV07XG4gICAgZGVsZXRlIHRoaXMucmVqZWN0b3JzW2tleV07XG4gICAgZGVsZXRlIHRoaXMuZmV0Y2hlZFtrZXldO1xuICAgIGRlbGV0ZSB0aGlzLmZldGNoZWRBdFtrZXldO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldExhc3RSZXNldCgpIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwRGF0ZSkgcmV0dXJuIHRoaXMuY2xlYW51cERhdGU7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbGxlci5nZXRTdGF0ZSgpLmxhc3RSZXNldDtcbiAgfVxuXG4gIC8qKiBDYWxsZWQgd2hlbiBtaWRkbGV3YXJlIGludGVyY2VwdHMgJ3Jlc3QtaG9va3MvZmV0Y2gnIGFjdGlvbi5cbiAgICpcbiAgICogV2lsbCB0aGVuIHN0YXJ0IGEgcHJvbWlzZSBmb3IgYSBrZXkgYW5kIHBvdGVudGlhbGx5IHN0YXJ0IHRoZSBuZXR3b3JrXG4gICAqIGZldGNoLlxuICAgKlxuICAgKiBVc2VzIHRocm90dGxlIG9ubHkgd2hlbiBpbnN0cnVjdGVkIGJ5IGFjdGlvbiBtZXRhLiBUaGlzIGlzIHZhbHVhYmxlXG4gICAqIGZvciBlbnN1cmVzIG11dGF0aW9uIHJlcXVlc3RzIGFsd2F5cyBnbyB0aHJvdWdoLlxuICAgKi9cbiAgcHJvdGVjdGVkIGhhbmRsZUZldGNoKGFjdGlvbjogRmV0Y2hBY3Rpb24pIHtcbiAgICBjb25zdCBmZXRjaCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHsga2V5LCB0aHJvdHRsZSwgcmVzb2x2ZSwgcmVqZWN0LCBjcmVhdGVkQXQgfSA9IGFjdGlvbi5tZXRhO1xuXG4gICAgY29uc3QgZGVmZXJlZEZldGNoID0gKCkgPT4ge1xuICAgICAgbGV0IHByb21pc2UgPSBmZXRjaCgpO1xuICAgICAgY29uc3QgcmVzb2x2ZVByb21pc2UgPSAoXG4gICAgICAgIHByb21pc2U6IFByb21pc2U8c3RyaW5nIHwgbnVtYmVyIHwgb2JqZWN0IHwgbnVsbD4sXG4gICAgICApID0+XG4gICAgICAgIHByb21pc2VcbiAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAvLyBzY2hlZHVsZSBub24tdGhyb3R0bGVkIHJlc29sdXRpb25zIGluIGEgbWljcm90YXNrIGJlZm9yZSByZWNlaXZlXG4gICAgICAvLyB0aGlzIGVuYWJsZXMgdXNlcnMgYXdhaXRpbmcgdGhlaXIgZmV0Y2ggdG8gdHJpZ2dlciBhbnkgcmVhY3QgdXBkYXRlcyBuZWVkZWQgdG8gZGVhbFxuICAgICAgLy8gd2l0aCB1cGNvbWluZyBjaGFuZ2VzIGJlY2F1c2Ugb2YgdGhlIGZldGNoIChmb3IgaW5zdGFuY2UgYXZvaWRpbmcgc3VzcGVuc2UgaWYgc29tZXRoaW5nIGlzIGRlbGV0ZWQpXG4gICAgICBpZiAoIXRocm90dGxlKSB7XG4gICAgICAgIHByb21pc2UgPSByZXNvbHZlUHJvbWlzZShwcm9taXNlKTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UgPSBwcm9taXNlXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgIGxldCBsYXN0UmVzZXQgPSB0aGlzLmdldExhc3RSZXNldCgpO1xuXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc05hTihsYXN0UmVzZXQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnc3RhdGUubGFzdFJlc2V0IGlzIE5hTi4gT25seSBwb3NpdGl2ZSB0aW1lc3RhbXBzIGFyZSB2YWxpZC4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxhc3RSZXNldCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIHN0YXRlIHdpdGggcHJvbWlzZXMgc3RhcnRlZCBiZWZvcmUgbGFzdCBjbGVhclxuICAgICAgICAgIGlmIChjcmVhdGVkQXQgPj0gbGFzdFJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIucmVzb2x2ZShhY3Rpb24uZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgYXJnczogYWN0aW9uLm1ldGEuYXJncyBhcyBhbnksXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBkYXRhLFxuICAgICAgICAgICAgICBmZXRjaGVkQXQ6IGNyZWF0ZWRBdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zdCBsYXN0UmVzZXQgPSB0aGlzLmdldExhc3RSZXNldCgpO1xuICAgICAgICAgIC8vIGRvbid0IHVwZGF0ZSBzdGF0ZSB3aXRoIHByb21pc2VzIHN0YXJ0ZWQgYmVmb3JlIGxhc3QgY2xlYXJcbiAgICAgICAgICBpZiAoY3JlYXRlZEF0ID49IGxhc3RSZXNldCkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLnJlc29sdmUoYWN0aW9uLmVuZHBvaW50LCB7XG4gICAgICAgICAgICAgIGFyZ3M6IGFjdGlvbi5tZXRhLmFyZ3MgYXMgYW55LFxuICAgICAgICAgICAgICByZXNwb25zZTogZXJyb3IsXG4gICAgICAgICAgICAgIGZldGNoZWRBdDogY3JlYXRlZEF0LFxuICAgICAgICAgICAgICBlcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgaWYgKHRocm90dGxlKSB7XG4gICAgICByZXR1cm4gdGhpcy50aHJvdHRsZShrZXksIGRlZmVyZWRGZXRjaCwgY3JlYXRlZEF0KVxuICAgICAgICAudGhlbihkYXRhID0+IHJlc29sdmUoZGF0YSkpXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiByZWplY3QoZXJyb3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZmVyZWRGZXRjaCgpLmNhdGNoKCgpID0+IHt9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQ2FsbGVkIHdoZW4gbWlkZGxld2FyZSBpbnRlcmNlcHRzIGEgcmVjZWl2ZSBhY3Rpb24uXG4gICAqXG4gICAqIFdpbGwgcmVzb2x2ZSB0aGUgcHJvbWlzZSBhc3NvY2lhdGVkIHdpdGggcmVjZWl2ZSBrZXkuXG4gICAqL1xuICBwcm90ZWN0ZWQgaGFuZGxlUmVjZWl2ZShhY3Rpb246IFNldEFjdGlvbikge1xuICAgIC8vIHRoaXMgY2FuIHN0aWxsIHR1cm4gb3V0IHRvIGJlIHVudHJ1ZSBzaW5jZSB0aGlzIGlzIGFzeW5jXG4gICAgaWYgKGFjdGlvbi5tZXRhLmtleSBpbiB0aGlzLmZldGNoZWQpIHtcbiAgICAgIGxldCBwcm9taXNlSGFuZGxlcjogKHZhbHVlPzogYW55KSA9PiB2b2lkO1xuICAgICAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgICAgICBwcm9taXNlSGFuZGxlciA9IHRoaXMucmVqZWN0b3JzW2FjdGlvbi5tZXRhLmtleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlSGFuZGxlciA9IHRoaXMucmVzb2x2ZXJzW2FjdGlvbi5tZXRhLmtleV07XG4gICAgICB9XG4gICAgICBwcm9taXNlSGFuZGxlcihhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAvLyBzaW5jZSB3ZSdyZSByZXNvbHZlZCB3ZSBubyBsb25nZXIgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoaXMgcHJvbWlzZVxuICAgICAgdGhpcy5jbGVhcihhY3Rpb24ubWV0YS5rZXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBBdHRhY2hlcyBOZXR3b3JrTWFuYWdlciB0byBzdG9yZVxuICAgKlxuICAgKiBJbnRlcmNlcHRzICdyZXN0LWhvb2tzL2ZldGNoJyBhY3Rpb25zIHRvIHN0YXJ0IHJlcXVlc3RzLlxuICAgKlxuICAgKiBSZXNvbHZlL3JlamVjdHMgYSByZXF1ZXN0IHdoZW4gbWF0Y2hpbmcgJ3Jlc3QtaG9va3MvcmVjZWl2ZScgZXZlbnRcbiAgICogaXMgc2Vlbi5cbiAgICovXG4gIGdldE1pZGRsZXdhcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlkZGxld2FyZTtcbiAgfVxuXG4gIC8qKiBFbnN1cmVzIG9ubHkgb25lIHJlcXVlc3QgZm9yIGEgZ2l2ZW4ga2V5IGlzIGluIGZsaWdodCBhdCBhbnkgdGltZVxuICAgKlxuICAgKiBVc2VzIGtleSB0byBlaXRoZXIgcmV0cmlldmUgaW4tZmxpZ2h0IHByb21pc2UsIG9yIGlmIG5vdFxuICAgKiBjcmVhdGUgYSBuZXcgcHJvbWlzZSBhbmQgY2FsbCBmZXRjaC5cbiAgICpcbiAgICogTm90ZTogVGhlIG5ldyBwcm9taXNlIGlzIG5vdCBhY3R1YWxseSB0aWVkIHRvIGZldGNoIGF0IGFsbCxcbiAgICogYnV0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGV4cGVjdGVkICdyZWNpZXZlJyBhY3Rpb24gaXMgcHJvY2Vzc2VkLlxuICAgKiBUaGlzIGVuc3VyZXMgcHJvbWlzZXMgYXJlIHJlc29sdmVkIG9ubHkgb25jZSB0aGVpciBkYXRhIGlzIHByb2Nlc3NlZFxuICAgKiBieSB0aGUgcmVkdWNlci5cbiAgICovXG4gIHByb3RlY3RlZCB0aHJvdHRsZShcbiAgICBrZXk6IHN0cmluZyxcbiAgICBmZXRjaDogKCkgPT4gUHJvbWlzZTxhbnk+LFxuICAgIGNyZWF0ZWRBdDogbnVtYmVyLFxuICApIHtcbiAgICBjb25zdCBsYXN0UmVzZXQgPSB0aGlzLmdldExhc3RSZXNldCgpO1xuICAgIC8vIHdlJ3JlIGFscmVhZHkgZmV0Y2hpbmcgc28gcmV1c2UgdGhlIHByb21pc2VcbiAgICAvLyBmZXRjaGVzIGFmdGVyIHJlc2V0IGRvIG5vdCBjb3VudFxuICAgIGlmIChrZXkgaW4gdGhpcy5mZXRjaGVkICYmIHRoaXMuZmV0Y2hlZEF0W2tleV0gPiBsYXN0UmVzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoZWRba2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLmZldGNoZWRba2V5XSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZXJzW2tleV0gPSByZXNvbHZlO1xuICAgICAgdGhpcy5yZWplY3RvcnNba2V5XSA9IHJlamVjdDtcbiAgICB9KTtcbiAgICB0aGlzLmZldGNoZWRBdFtrZXldID0gY3JlYXRlZEF0O1xuXG4gICAgLy8gc2luY2Ugb3VyIHJlYWwgcHJvbWlzZSBpcyByZXNvbHZlZCB2aWEgdGhlIHdyYXBSZWR1Y2VyKCksXG4gICAgLy8gd2Ugc2hvdWxkIGp1c3Qgc3RvcCBhbGwgZXJyb3JzIGhlcmUuXG4gICAgLy8gVE9ETzogZGVjb3VwbGUgdGhpcyBmcm9tIHVzZUZldGNoZXIoKSAodGhhdCdzIHdoYXQncyBkaXNwYXRjaGluZyB0aGUgZXJyb3IgdGhlIHJlc29sdmVzIGluIGhlcmUpXG4gICAgUklDKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBmZXRjaCgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgfSxcbiAgICAgIHsgdGltZW91dDogNTAwIH0sXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLmZldGNoZWRba2V5XTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxRQUFRLG1CQUFtQjtBQUNwRSxPQUFPQyxVQUFVLE1BQU0sNkJBQTZCO0FBQ3BELE9BQU9DLFNBQVMsTUFBTSw0QkFBNEI7QUFDbEQsT0FBT0MsR0FBRyxNQUFNLGlCQUFpQjtBQVVqQyxPQUFPLE1BQU1DLFVBQVUsU0FBU0MsS0FBSyxDQUFDO0VBR3BDQyxXQUFXQSxDQUFBLEVBQUc7SUFDWixLQUFLLENBQUMsc0JBQXNCLENBQUM7SUFBQyxLQUhoQ0MsSUFBSSxHQUFHLFlBQVk7RUFJbkI7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU1DLGNBQWMsQ0FBb0I7RUFXckRGLFdBQVdBLENBQUNHLGdCQUFnQixHQUFHLEtBQUssRUFBRUMsaUJBQWlCLEdBQUcsSUFBSSxFQUFFO0lBQUEsS0FWdERDLE9BQU8sR0FBa0NDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQztJQUFBLEtBQzVEQyxTQUFTLEdBQTJDLENBQUMsQ0FBQztJQUFBLEtBQ3REQyxTQUFTLEdBQTJDLENBQUMsQ0FBQztJQUFBLEtBQ3REQyxTQUFTLEdBQTRCLENBQUMsQ0FBQztJQUFBLEtBSXZDQyxVQUFVLEdBQWUsSUFBSWhCLFVBQVUsQ0FBQyxDQUFDO0lBSWpELElBQUksQ0FBQ1EsZ0JBQWdCLEdBQUdBLGdCQUFnQjtJQUN4QyxJQUFJLENBQUNDLGlCQUFpQixHQUFHQSxpQkFBaUI7SUFFMUMsSUFBSSxDQUFDUSxVQUFVLEdBQTZCRCxVQUFhLElBQUs7TUFDNUQsSUFBSSxDQUFDQSxVQUFVLEdBQUdBLFVBQVU7TUFDNUIsT0FBUUUsSUFBbUIsSUFDeEJDLE1BQU0sSUFBb0I7UUFDekIsUUFBUUEsTUFBTSxDQUFDQyxJQUFJO1VBQ2pCLEtBQUt0QixVQUFVO1lBQ2IsSUFBSSxDQUFDdUIsV0FBVyxDQUFDRixNQUFNLENBQUM7WUFDeEI7WUFDQTtZQUNBO1lBQ0EsSUFDRUEsTUFBTSxDQUFDRyxRQUFRLENBQUNDLHFCQUFxQixLQUFLQyxTQUFTLElBQ25ETCxNQUFNLENBQUNHLFFBQVEsQ0FBQ0csVUFBVSxFQUMxQjtjQUNBLE9BQU9QLElBQUksQ0FBQ0MsTUFBTSxDQUFDO1lBQ3JCO1lBQ0EsT0FBT08sT0FBTyxDQUFDQyxPQUFPLENBQUMsQ0FBQztVQUMxQixLQUFLOUIsUUFBUTtZQUNYO1lBQ0EsT0FBT3FCLElBQUksQ0FBQ0MsTUFBTSxDQUFDLENBQUNTLElBQUksQ0FBQyxNQUFNO2NBQzdCLElBQUlULE1BQU0sQ0FBQ1UsSUFBSSxDQUFDQyxHQUFHLElBQUksSUFBSSxDQUFDcEIsT0FBTyxFQUFFO2dCQUFBLElBQUFxQixxQkFBQTtnQkFDbkM7Z0JBQ0EsTUFBTUMsS0FBSyxJQUFBRCxxQkFBQSxHQUNUZixVQUFVLENBQUNpQixRQUFRLENBQUMsQ0FBQyxDQUFDSixJQUFJLENBQUNWLE1BQU0sQ0FBQ1UsSUFBSSxDQUFDQyxHQUFHLENBQUMscUJBQTNDQyxxQkFBQSxDQUE2Q0MsS0FBSztnQkFDcEQ7Z0JBQ0EsSUFBSUEsS0FBSyxFQUFFO2tCQUNULElBQUksQ0FBQ0UsYUFBYSxDQUNoQmpDLFNBQVMsQ0FBQ2tCLE1BQU0sQ0FBQ0csUUFBUSxFQUFFO29CQUN6QmEsSUFBSSxFQUFFaEIsTUFBTSxDQUFDVSxJQUFJLENBQUNNLElBQVc7b0JBQzdCQyxRQUFRLEVBQUVKLEtBQUs7b0JBQ2ZqQixTQUFTLEVBQUVJLE1BQU0sQ0FBQ1UsSUFBSSxDQUFDZCxTQUFTO29CQUNoQ2lCLEtBQUssRUFBRTtrQkFDVCxDQUFDLENBQ0gsQ0FBQztnQkFDSCxDQUFDLE1BQU07a0JBQ0wsSUFBSSxDQUFDRSxhQUFhLENBQUNmLE1BQU0sQ0FBQztnQkFDNUI7Y0FDRjtZQUNGLENBQUMsQ0FBQztVQUNKLEtBQUtwQixVQUFVO1lBQUU7Y0FDZixNQUFNZSxTQUFTLEdBQUFILE1BQUEsQ0FBQTBCLE1BQUEsS0FBUSxJQUFJLENBQUN2QixTQUFTLENBQUU7Y0FFdkMsSUFBSSxDQUFDd0IsUUFBUSxDQUFDLENBQUM7Y0FDZixPQUFPcEIsSUFBSSxDQUFDQyxNQUFNLENBQUMsQ0FBQ1MsSUFBSSxDQUFDLE1BQU07Z0JBQzdCO2dCQUNBO2dCQUNBLEtBQUssTUFBTVcsQ0FBQyxJQUFJekIsU0FBUyxFQUFFO2tCQUN6QkEsU0FBUyxDQUFDeUIsQ0FBQyxDQUFDLENBQUMsSUFBSXBDLFVBQVUsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hDO2NBQ0YsQ0FBQyxDQUFDO1lBQ0o7VUFDQTtZQUNFLE9BQU9lLElBQUksQ0FBQ0MsTUFBTSxDQUFDO1FBQ3ZCO01BQ0YsQ0FBQztJQUNMLENBQUM7RUFDSDs7RUFFQTtFQUNBcUIsV0FBV0EsQ0FBQ3JCLE1BQW1CLEVBQUU7SUFDL0I7SUFDQSxPQUFPQSxNQUFNLENBQUNDLElBQUksS0FBS3RCLFVBQVUsSUFBSXFCLE1BQU0sQ0FBQ1UsSUFBSSxDQUFDQyxHQUFHLElBQUksSUFBSSxDQUFDcEIsT0FBTztFQUN0RTs7RUFFQTtFQUNBK0IsSUFBSUEsQ0FBQSxFQUFHO0lBQ0wsT0FBTyxJQUFJLENBQUNDLFdBQVc7RUFDekI7O0VBRUE7RUFDQUMsT0FBT0EsQ0FBQSxFQUFHO0lBQ1I7SUFDQTtJQUNBLElBQUksQ0FBQ0QsV0FBVyxHQUFHRSxJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDO0VBQy9CO0VBRUFDLFVBQVVBLENBQUEsRUFBRztJQUNYLE1BQU1DLE9BQU8sR0FBR3BDLE1BQU0sQ0FBQ3FDLE1BQU0sQ0FBQyxJQUFJLENBQUN0QyxPQUFPLENBQUM7SUFDM0MsSUFBSXFDLE9BQU8sQ0FBQ0UsTUFBTSxFQUFFLE9BQU92QixPQUFPLENBQUNvQixVQUFVLENBQUNDLE9BQU8sQ0FBQztFQUN4RDs7RUFFQTtFQUNVVCxRQUFRQSxDQUFBLEVBQUc7SUFDbkIsS0FBSyxNQUFNQyxDQUFDLElBQUksSUFBSSxDQUFDekIsU0FBUyxFQUFFO01BQzlCLElBQUksQ0FBQ29DLEtBQUssQ0FBQ1gsQ0FBQyxDQUFDO0lBQ2Y7RUFDRjs7RUFFQTtFQUNVVyxLQUFLQSxDQUFDcEIsR0FBVyxFQUFFO0lBQzNCLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ29CLEdBQUcsQ0FBQyxDQUFDcUIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDakMsT0FBTyxJQUFJLENBQUN0QyxTQUFTLENBQUNpQixHQUFHLENBQUM7SUFDMUIsT0FBTyxJQUFJLENBQUNoQixTQUFTLENBQUNnQixHQUFHLENBQUM7SUFDMUIsT0FBTyxJQUFJLENBQUNwQixPQUFPLENBQUNvQixHQUFHLENBQUM7SUFDeEIsT0FBTyxJQUFJLENBQUNmLFNBQVMsQ0FBQ2UsR0FBRyxDQUFDO0VBQzVCO0VBRVVzQixZQUFZQSxDQUFBLEVBQUc7SUFDdkIsSUFBSSxJQUFJLENBQUNWLFdBQVcsRUFBRSxPQUFPLElBQUksQ0FBQ0EsV0FBVztJQUM3QyxPQUFPLElBQUksQ0FBQzFCLFVBQVUsQ0FBQ2lCLFFBQVEsQ0FBQyxDQUFDLENBQUNvQixTQUFTO0VBQzdDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDWWhDLFdBQVdBLENBQUNGLE1BQW1CLEVBQUU7SUFDekMsTUFBTW1DLEtBQUssR0FBR25DLE1BQU0sQ0FBQ29DLE9BQU87SUFDNUIsTUFBTTtNQUFFekIsR0FBRztNQUFFMEIsUUFBUTtNQUFFN0IsT0FBTztNQUFFOEIsTUFBTTtNQUFFQztJQUFVLENBQUMsR0FBR3ZDLE1BQU0sQ0FBQ1UsSUFBSTtJQUVqRSxNQUFNOEIsWUFBWSxHQUFHQSxDQUFBLEtBQU07TUFDekIsSUFBSUMsT0FBTyxHQUFHTixLQUFLLENBQUMsQ0FBQztNQUNyQixNQUFNTyxjQUFjLEdBQ2xCRCxPQUFpRCxJQUVqREEsT0FBTyxDQUNKaEMsSUFBSSxDQUFDa0MsSUFBSSxJQUFJO1FBQ1puQyxPQUFPLENBQUNtQyxJQUFJLENBQUM7UUFDYixPQUFPQSxJQUFJO01BQ2IsQ0FBQyxDQUFDLENBQ0RYLEtBQUssQ0FBQ25CLEtBQUssSUFBSTtRQUNkeUIsTUFBTSxDQUFDekIsS0FBSyxDQUFDO1FBQ2IsTUFBTUEsS0FBSztNQUNiLENBQUMsQ0FBQztNQUNOO01BQ0E7TUFDQTtNQUNBLElBQUksQ0FBQ3dCLFFBQVEsRUFBRTtRQUNiSSxPQUFPLEdBQUdDLGNBQWMsQ0FBQ0QsT0FBTyxDQUFDO01BQ25DO01BQ0FBLE9BQU8sR0FBR0EsT0FBTyxDQUNkaEMsSUFBSSxDQUFDa0MsSUFBSSxJQUFJO1FBQ1osSUFBSVQsU0FBUyxHQUFHLElBQUksQ0FBQ0QsWUFBWSxDQUFDLENBQUM7O1FBRW5DO1FBQ0EsSUFBSVcsT0FBTyxDQUFDQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxZQUFZLElBQUlDLEtBQUssQ0FBQ2IsU0FBUyxDQUFDLEVBQUU7VUFDN0RjLE9BQU8sQ0FBQ25DLEtBQUssQ0FDWCw2REFDRixDQUFDO1VBQ0RxQixTQUFTLEdBQUcsQ0FBQztRQUNmOztRQUVBO1FBQ0EsSUFBSUssU0FBUyxJQUFJTCxTQUFTLEVBQUU7VUFDMUIsSUFBSSxDQUFDckMsVUFBVSxDQUFDVyxPQUFPLENBQUNSLE1BQU0sQ0FBQ0csUUFBUSxFQUFFO1lBQ3ZDYSxJQUFJLEVBQUVoQixNQUFNLENBQUNVLElBQUksQ0FBQ00sSUFBVztZQUM3QkMsUUFBUSxFQUFFMEIsSUFBSTtZQUNkL0MsU0FBUyxFQUFFMkM7VUFDYixDQUFDLENBQUM7UUFDSjtRQUNBLE9BQU9JLElBQUk7TUFDYixDQUFDLENBQUMsQ0FDRFgsS0FBSyxDQUFDbkIsS0FBSyxJQUFJO1FBQ2QsTUFBTXFCLFNBQVMsR0FBRyxJQUFJLENBQUNELFlBQVksQ0FBQyxDQUFDO1FBQ3JDO1FBQ0EsSUFBSU0sU0FBUyxJQUFJTCxTQUFTLEVBQUU7VUFDMUIsSUFBSSxDQUFDckMsVUFBVSxDQUFDVyxPQUFPLENBQUNSLE1BQU0sQ0FBQ0csUUFBUSxFQUFFO1lBQ3ZDYSxJQUFJLEVBQUVoQixNQUFNLENBQUNVLElBQUksQ0FBQ00sSUFBVztZQUM3QkMsUUFBUSxFQUFFSixLQUFLO1lBQ2ZqQixTQUFTLEVBQUUyQyxTQUFTO1lBQ3BCMUIsS0FBSyxFQUFFO1VBQ1QsQ0FBQyxDQUFDO1FBQ0o7UUFDQSxNQUFNQSxLQUFLO01BQ2IsQ0FBQyxDQUFDO01BQ0osT0FBTzRCLE9BQU87SUFDaEIsQ0FBQztJQUVELElBQUlKLFFBQVEsRUFBRTtNQUNaLE9BQU8sSUFBSSxDQUFDQSxRQUFRLENBQUMxQixHQUFHLEVBQUU2QixZQUFZLEVBQUVELFNBQVMsQ0FBQyxDQUMvQzlCLElBQUksQ0FBQ2tDLElBQUksSUFBSW5DLE9BQU8sQ0FBQ21DLElBQUksQ0FBQyxDQUFDLENBQzNCWCxLQUFLLENBQUNuQixLQUFLLElBQUl5QixNQUFNLENBQUN6QixLQUFLLENBQUMsQ0FBQztJQUNsQyxDQUFDLE1BQU07TUFDTCxPQUFPMkIsWUFBWSxDQUFDLENBQUMsQ0FBQ1IsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDdkM7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNZakIsYUFBYUEsQ0FBQ2YsTUFBaUIsRUFBRTtJQUN6QztJQUNBLElBQUlBLE1BQU0sQ0FBQ1UsSUFBSSxDQUFDQyxHQUFHLElBQUksSUFBSSxDQUFDcEIsT0FBTyxFQUFFO01BQ25DLElBQUkwRCxjQUFxQztNQUN6QyxJQUFJakQsTUFBTSxDQUFDYSxLQUFLLEVBQUU7UUFDaEJvQyxjQUFjLEdBQUcsSUFBSSxDQUFDdEQsU0FBUyxDQUFDSyxNQUFNLENBQUNVLElBQUksQ0FBQ0MsR0FBRyxDQUFDO01BQ2xELENBQUMsTUFBTTtRQUNMc0MsY0FBYyxHQUFHLElBQUksQ0FBQ3ZELFNBQVMsQ0FBQ00sTUFBTSxDQUFDVSxJQUFJLENBQUNDLEdBQUcsQ0FBQztNQUNsRDtNQUNBc0MsY0FBYyxDQUFDakQsTUFBTSxDQUFDb0MsT0FBTyxDQUFDO01BQzlCO01BQ0EsSUFBSSxDQUFDTCxLQUFLLENBQUMvQixNQUFNLENBQUNVLElBQUksQ0FBQ0MsR0FBRyxDQUFDO0lBQzdCO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRXVDLGFBQWFBLENBQUEsRUFBRztJQUNkLE9BQU8sSUFBSSxDQUFDcEQsVUFBVTtFQUN4Qjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNZdUMsUUFBUUEsQ0FDaEIxQixHQUFXLEVBQ1h3QixLQUF5QixFQUN6QkksU0FBaUIsRUFDakI7SUFDQSxNQUFNTCxTQUFTLEdBQUcsSUFBSSxDQUFDRCxZQUFZLENBQUMsQ0FBQztJQUNyQztJQUNBO0lBQ0EsSUFBSXRCLEdBQUcsSUFBSSxJQUFJLENBQUNwQixPQUFPLElBQUksSUFBSSxDQUFDSyxTQUFTLENBQUNlLEdBQUcsQ0FBQyxHQUFHdUIsU0FBUyxFQUFFO01BQzFELE9BQU8sSUFBSSxDQUFDM0MsT0FBTyxDQUFDb0IsR0FBRyxDQUFDO0lBQzFCO0lBRUEsSUFBSSxDQUFDcEIsT0FBTyxDQUFDb0IsR0FBRyxDQUFDLEdBQUcsSUFBSUosT0FBTyxDQUFDLENBQUNDLE9BQU8sRUFBRThCLE1BQU0sS0FBSztNQUNuRCxJQUFJLENBQUM1QyxTQUFTLENBQUNpQixHQUFHLENBQUMsR0FBR0gsT0FBTztNQUM3QixJQUFJLENBQUNiLFNBQVMsQ0FBQ2dCLEdBQUcsQ0FBQyxHQUFHMkIsTUFBTTtJQUM5QixDQUFDLENBQUM7SUFDRixJQUFJLENBQUMxQyxTQUFTLENBQUNlLEdBQUcsQ0FBQyxHQUFHNEIsU0FBUzs7SUFFL0I7SUFDQTtJQUNBO0lBQ0F4RCxHQUFHLENBQ0QsTUFBTTtNQUNKb0QsS0FBSyxDQUFDLENBQUMsQ0FBQ0gsS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDO0lBQzNCLENBQUMsRUFDRDtNQUFFbUIsT0FBTyxFQUFFO0lBQUksQ0FDakIsQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDNUQsT0FBTyxDQUFDb0IsR0FBRyxDQUFDO0VBQzFCO0FBQ0YifQ==