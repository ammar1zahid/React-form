'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var normalizr = require('@data-client/normalizr');

const FETCH_TYPE = 'rest-hooks/fetch';
/** @deprecated use SET_TYPE instead */
const RECEIVE_TYPE = 'rest-hooks/receive';
const SET_TYPE = RECEIVE_TYPE;
const RESET_TYPE = 'rest-hooks/reset';
const SUBSCRIBE_TYPE = 'rest-hooks/subscribe';
const UNSUBSCRIBE_TYPE = 'rest-hook/unsubscribe';
const INVALIDATE_TYPE = 'rest-hooks/invalidate';
const INVALIDATEALL_TYPE = 'rest-hooks/invalidateall';
const EXPIREALL_TYPE = 'rest-hooks/expireall';

function createExpireAll(testKey) {
  return {
    type: EXPIREALL_TYPE,
    testKey
  };
}

/**
 * Requesting a fetch to begin
 */
function createFetch(endpoint, {
  args
}) {
  const key = endpoint.key(...args);
  let resolve = 0;
  let reject = 0;
  const promise = new Promise((a, b) => {
    [resolve, reject] = [a, b];
  });
  const meta = {
    args,
    key,
    throttle: !endpoint.sideEffect,
    resolve,
    reject,
    promise,
    createdAt: Date.now(),
    nm: false
  };
  return {
    type: FETCH_TYPE,
    payload: () => endpoint(...args),
    meta,
    endpoint
  };
}

function createInvalidate(endpoint, {
  args
}) {
  return {
    type: INVALIDATE_TYPE,
    meta: {
      key: endpoint.key(...args)
    }
  };
}

function createInvalidateAll(testKey) {
  return {
    type: INVALIDATEALL_TYPE,
    testKey
  };
}

function createReset() {
  return {
    type: RESET_TYPE,
    date: Date.now()
  };
}

const ensurePojo =
// FormData doesn't exist in node
/* istanbul ignore else we don't run coverage when we test node*/
typeof FormData !== 'undefined' ? body => body instanceof FormData ? Object.fromEntries(body.entries()) : body : /* istanbul ignore next */
body => body;
var ensurePojo$1 = ensurePojo;

function createSet(endpoint, {
  args,
  fetchedAt,
  response,
  error = false
}) {
  var _endpoint$errorExpiry, _endpoint$dataExpiryL;
  const expiryLength = error ? (_endpoint$errorExpiry = endpoint.errorExpiryLength) != null ? _endpoint$errorExpiry : 1000 : (_endpoint$dataExpiryL = endpoint.dataExpiryLength) != null ? _endpoint$dataExpiryL : 60000;
  /* istanbul ignore next */
  if (process.env.NODE_ENV === 'development' && expiryLength < 0) {
    throw new Error('Negative expiry length are not allowed.');
  }
  const now = Date.now();
  const meta = {
    args: args.map(ensurePojo$1),
    fetchedAt: fetchedAt != null ? fetchedAt : now,
    date: now,
    expiresAt: now + expiryLength,
    key: endpoint.key(...args)
  };
  const action = {
    type: SET_TYPE,
    payload: response,
    endpoint: endpoint,
    meta
  };
  if (error) action.error = true;
  return action;
}

function createSubscription(endpoint, {
  args
}) {
  return {
    type: SUBSCRIBE_TYPE,
    endpoint,
    meta: {
      args,
      key: endpoint.key(...args)
    }
  };
}
function createUnsubscription(endpoint, {
  args
}) {
  return {
    type: UNSUBSCRIBE_TYPE,
    endpoint,
    meta: {
      args,
      key: endpoint.key(...args)
    }
  };
}

const initialState = {
  entities: {},
  indexes: {},
  results: {},
  meta: {},
  entityMeta: {},
  optimistic: [],
  lastReset: 0
};

function selectMeta(state, fetchKey) {
  return state.meta[fetchKey];
}

const unsetDispatch = action => {
  throw new Error(`Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.`);
};
const unsetState = () => {
  // This is only the value until it is set by the CacheProvider
  /* istanbul ignore next */
  return initialState;
};

/**
 * Imperative control of Rest Hooks store
 * @see https://resthooks.io/docs/api/Controller
 */
class Controller {
  /**
   * Dispatches an action to Rest Hooks reducer.
   *
   * @see https://resthooks.io/docs/api/Controller#dispatch
   */

  /**
   * Gets the latest state snapshot that is fully committed.
   *
   * This can be useful for imperative use-cases like event handlers.
   * This should *not* be used to render; instead useSuspense() or useCache()
   * @see https://resthooks.io/docs/api/Controller#getState
   */

  constructor({
    dispatch = unsetDispatch,
    getState = unsetState,
    globalCache = {
      entities: {},
      results: {}
    }
  } = {}) {
    /*************** Action Dispatchers ***************/
    /**
     * Fetches the endpoint with given args, updating the Rest Hooks cache with the response or error upon completion.
     * @see https://resthooks.io/docs/api/Controller#fetch
     */
    this.fetch = (endpoint, ...args) => {
      const action = createFetch(endpoint, {
        args
      });
      this.dispatch(action);
      if (endpoint.schema) {
        return action.meta.promise.then(input => normalizr.denormalize(input, endpoint.schema, {}, args));
      }
      return action.meta.promise;
    };
    /**
     * Fetches only if endpoint is considered 'stale'; otherwise returns undefined
     * @see https://dataclient.io/docs/api/Controller#fetchIfStale
     */
    this.fetchIfStale = (endpoint, ...args) => {
      const {
        data,
        expiresAt,
        expiryStatus
      } = this.getResponse(endpoint, ...args, this.getState());
      if (expiryStatus !== normalizr.ExpiryStatus.Invalid && Date.now() <= expiresAt) return data;
      return this.fetch(endpoint, ...args);
    };
    /**
     * Forces refetching and suspense on useSuspense with the same Endpoint and parameters.
     * @see https://resthooks.io/docs/api/Controller#invalidate
     */
    this.invalidate = (endpoint, ...args) => args[0] !== null ? this.dispatch(createInvalidate(endpoint, {
      args: args
    })) : Promise.resolve();
    /**
     * Forces refetching and suspense on useSuspense on all matching endpoint result keys.
     * @see https://resthooks.io/docs/api/Controller#invalidateAll
     * @returns Promise that resolves when invalidation is commited.
     */
    this.invalidateAll = options => this.dispatch(createInvalidateAll(key => options.testKey(key)));
    /**
     * Sets all matching endpoint result keys to be STALE.
     * @see https://dataclient.io/docs/api/Controller#expireAll
     * @returns Promise that resolves when expiry is commited. *NOT* fetch promise
     */
    this.expireAll = options => this.dispatch(createExpireAll(key => options.testKey(key)));
    /**
     * Resets the entire Rest Hooks cache. All inflight requests will not resolve.
     * @see https://resthooks.io/docs/api/Controller#resetEntireStore
     */
    this.resetEntireStore = () => this.dispatch(createReset());
    /**
     * Stores response in cache for given Endpoint and args.
     * @see https://resthooks.io/docs/api/Controller#set
     */
    this.setResponse = (endpoint, ...rest) => {
      const response = rest[rest.length - 1];
      const action = createSet(endpoint, {
        args: rest.slice(0, rest.length - 1),
        response
      });
      return this.dispatch(action);
    };
    /**
     * @deprecated use https://resthooks.io/docs/api/Controller#setResponse instead
     */
    /* istanbul ignore next */
    this.receive = (endpoint, ...rest) => {
      /* istanbul ignore next */
      return this.setResponse(endpoint, ...rest);
    };
    /**
     * Stores the result of Endpoint and args as the error provided.
     * @see https://resthooks.io/docs/api/Controller#setError
     */
    this.setError = (endpoint, ...rest) => {
      const response = rest[rest.length - 1];
      const action = createSet(endpoint, {
        args: rest.slice(0, rest.length - 1),
        response,
        error: true
      });
      return this.dispatch(action);
    };
    /**
     * Another name for setError
     * @deprecated use https://resthooks.io/docs/api/Controller#setError instead
     */
    /* istanbul ignore next */
    this.receiveError = (endpoint, ...rest) => {
      /* istanbul ignore next */
      return this.setError(endpoint, ...rest);
    };
    /**
     * Resolves an inflight fetch. `fetchedAt` should `fetch`'s `createdAt`
     * @see https://resthooks.io/docs/api/Controller#resolve
     */
    this.resolve = (endpoint, meta) => {
      return this.dispatch(createSet(endpoint, meta));
    };
    /**
     * Marks a new subscription to a given Endpoint.
     * @see https://resthooks.io/docs/api/Controller#subscribe
     */
    this.subscribe = (endpoint, ...args) => args[0] !== null ? this.dispatch(createSubscription(endpoint, {
      args: args
    })) : Promise.resolve();
    /**
     * Marks completion of subscription to a given Endpoint.
     * @see https://resthooks.io/docs/api/Controller#unsubscribe
     */
    this.unsubscribe = (endpoint, ...args) => args[0] !== null ? this.dispatch(createUnsubscription(endpoint, {
      args: args
    })) : Promise.resolve();
    /*************** More ***************/
    /* TODO:
    abort = <E extends EndpointInterface>(
      endpoint: E,
      ...args: readonly [...Parameters<E>]
    ): Promise<void>
    */
    /**
     * Gets a snapshot (https://resthooks.io/docs/api/Snapshot)
     * @see https://resthooks.io/docs/api/Controller#snapshot
     */
    this.snapshot = (state, fetchedAt) => {
      return new Snapshot(this, state, fetchedAt);
    };
    /**
     * Gets the error, if any, for a given endpoint. Returns undefined for no errors.
     * @see https://resthooks.io/docs/api/Controller#getError
     */
    this.getError = (endpoint, ...rest) => {
      if (rest[0] === null) return;
      const state = rest[rest.length - 1];
      // this is typescript generics breaking
      const args = rest.slice(0, rest.length - 1);
      const key = endpoint.key(...args);
      const meta = selectMeta(state, key);
      const results = state.results[key];
      if (results !== undefined && (meta == null ? void 0 : meta.errorPolicy) === 'soft') return;
      return meta == null ? void 0 : meta.error;
    };
    /**
     * Gets the (globally referentially stable) response for a given endpoint/args pair from state given.
     * @see https://resthooks.io/docs/api/Controller#getResponse
     */
    this.getResponse = (endpoint, ...rest) => {
      const state = rest[rest.length - 1];
      // this is typescript generics breaking
      const args = rest.slice(0, rest.length - 1).map(ensurePojo$1);
      const isActive = args.length !== 1 || args[0] !== null;
      const key = isActive ? endpoint.key(...args) : '';
      const cacheResults = isActive ? state.results[key] : undefined;
      const schema = endpoint.schema;
      const meta = selectMeta(state, key);
      let expiresAt = meta == null ? void 0 : meta.expiresAt;
      let invalidResults = false;
      let results;
      if (cacheResults === undefined && endpoint.schema !== undefined) {
        results = normalizr.inferResults(endpoint.schema, args, state.indexes, state.entities);
        invalidResults = !normalizr.validateInference(results);
        if (!expiresAt && invalidResults) expiresAt = 1;
      } else {
        results = cacheResults;
      }
      if (!isActive) {
        return {
          data: results,
          expiryStatus: normalizr.ExpiryStatus.Valid,
          expiresAt: Infinity
        };
      }
      if (!endpoint.schema || !schemaHasEntity(endpoint.schema)) {
        return {
          data: results,
          expiryStatus: meta != null && meta.invalidated ? normalizr.ExpiryStatus.Invalid : cacheResults && !endpoint.invalidIfStale ? normalizr.ExpiryStatus.Valid : normalizr.ExpiryStatus.InvalidIfStale,
          expiresAt: expiresAt || 0
        };
      }
      if (!this.globalCache.results[key]) this.globalCache.results[key] = new normalizr.WeakEntityMap();

      // second argument is false if any entities are missing
      // eslint-disable-next-line prefer-const
      const {
        data,
        paths
      } = normalizr.denormalizeCached(results, schema, state.entities, this.globalCache.entities, this.globalCache.results[key], args);
      const invalidDenormalize = typeof data === 'symbol';

      // fallback to entity expiry time
      if (!expiresAt) {
        expiresAt = entityExpiresAt(paths, state.entityMeta);
      }

      // https://resthooks.io/docs/concepts/expiry-policy#expiry-status
      // we don't track the difference between stale or fresh because that is tied to triggering
      // conditions
      const expiryStatus = meta != null && meta.invalidated || invalidDenormalize && !(meta != null && meta.error) ? normalizr.ExpiryStatus.Invalid : invalidDenormalize || endpoint.invalidIfStale || invalidResults ? normalizr.ExpiryStatus.InvalidIfStale : normalizr.ExpiryStatus.Valid;
      return {
        data,
        expiryStatus,
        expiresAt
      };
    };
    this.dispatch = dispatch;
    this.getState = getState;
    this.globalCache = globalCache;
  }
}

// benchmark: https://www.measurethat.net/Benchmarks/Show/24691/0/min-reducer-vs-imperative-with-paths
// earliest expiry dictates age
function entityExpiresAt(paths, entityMeta) {
  let expiresAt = Infinity;
  for (const {
    pk,
    key
  } of paths) {
    var _entityMeta$key, _entityMeta$key$pk;
    const entityExpiry = (_entityMeta$key = entityMeta[key]) == null ? void 0 : (_entityMeta$key$pk = _entityMeta$key[pk]) == null ? void 0 : _entityMeta$key$pk.expiresAt;
    // expiresAt will always resolve to false with any comparison
    if (entityExpiry < expiresAt) expiresAt = entityExpiry;
  }
  return expiresAt;
}

/** Determine whether the schema has any entities.
 *
 * Without entities, denormalization is not needed, and results should not be inferred.
 */
function schemaHasEntity(schema) {
  if (normalizr.isEntity(schema)) return true;
  if (Array.isArray(schema)) return schema.length !== 0 && schemaHasEntity(schema[0]);
  if (schema && (typeof schema === 'object' || typeof schema === 'function')) {
    const nestedSchema = 'schema' in schema ? schema.schema : schema;
    if (typeof nestedSchema === 'function') {
      return schemaHasEntity(nestedSchema);
    }
    return Object.values(nestedSchema).some(x => schemaHasEntity(x));
  }
  return false;
}
class Snapshot {
  constructor(controller, state, fetchedAt = 0) {
    this.state = void 0;
    this.controller = void 0;
    this.fetchedAt = void 0;
    /*************** Data Access ***************/
    /** @see https://resthooks.io/docs/api/Snapshot#getResponse */
    this.getResponse = (endpoint, ...args) => {
      return this.controller.getResponse(endpoint, ...args, this.state);
    };
    /** @see https://resthooks.io/docs/api/Snapshot#getError */
    this.getError = (endpoint, ...args) => {
      return this.controller.getError(endpoint, ...args, this.state);
    };
    this.state = state;
    this.controller = controller;
    this.fetchedAt = fetchedAt;
  }
}

exports.Controller = Controller;
