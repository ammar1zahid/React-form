'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var normalizr = require('@data-client/normalizr');

const RIC = typeof requestIdleCallback === 'function' ? requestIdleCallback : cb => setTimeout(cb, 0);
var RIC$1 = RIC;

function expireReducer(state, action) {
  const meta = {
    ...state.meta
  };
  Object.keys(meta).forEach(key => {
    if (action.testKey(key)) {
      meta[key] = {
        ...meta[key],
        // 1 instead of 0 so we can do 'falsy' checks to see if it is set
        expiresAt: 1
      };
    }
  });
  return {
    ...state,
    meta
  };
}

const FETCH_TYPE = 'rest-hooks/fetch';
/** @deprecated use SET_TYPE instead */
const RECEIVE_TYPE = 'rest-hooks/receive';
const SET_TYPE = RECEIVE_TYPE;
const OPTIMISTIC_TYPE = 'rest-hooks/optimistic';
const RESET_TYPE = 'rest-hooks/reset';
const SUBSCRIBE_TYPE = 'rest-hooks/subscribe';
const UNSUBSCRIBE_TYPE = 'rest-hook/unsubscribe';
const INVALIDATE_TYPE = 'rest-hooks/invalidate';
const INVALIDATEALL_TYPE = 'rest-hooks/invalidateall';
const EXPIREALL_TYPE = 'rest-hooks/expireall';
const GC_TYPE = 'rest-hooks/gc';

var actionTypes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  FETCH_TYPE: FETCH_TYPE,
  RECEIVE_TYPE: RECEIVE_TYPE,
  SET_TYPE: SET_TYPE,
  OPTIMISTIC_TYPE: OPTIMISTIC_TYPE,
  RESET_TYPE: RESET_TYPE,
  SUBSCRIBE_TYPE: SUBSCRIBE_TYPE,
  UNSUBSCRIBE_TYPE: UNSUBSCRIBE_TYPE,
  INVALIDATE_TYPE: INVALIDATE_TYPE,
  INVALIDATEALL_TYPE: INVALIDATEALL_TYPE,
  EXPIREALL_TYPE: EXPIREALL_TYPE,
  GC_TYPE: GC_TYPE
});

function createOptimistic(endpoint, {
  args,
  fetchedAt
}) {
  var _endpoint$dataExpiryL;
  const expiryLength = (_endpoint$dataExpiryL = endpoint.dataExpiryLength) != null ? _endpoint$dataExpiryL : 60000;
  /* istanbul ignore next */
  if (process.env.NODE_ENV === 'development' && expiryLength < 0) {
    throw new Error('Negative expiry length are not allowed.');
  }
  const now = Date.now();
  const meta = {
    args,
    fetchedAt,
    date: now,
    expiresAt: now + expiryLength,
    key: endpoint.key(...args)
  };
  const action = {
    type: OPTIMISTIC_TYPE,
    endpoint,
    meta
  };
  return action;
}

function fetchReducer(state, action) {
  let receiveAction;
  if (action.endpoint.getOptimisticResponse && action.endpoint.sideEffect) {
    receiveAction = createOptimistic(action.endpoint, {
      args: action.meta.args,
      fetchedAt: action.meta.createdAt
    });
  } else {
    // If 'fetch' action reaches the reducer there are no middlewares installed to handle it
    /* istanbul ignore next */
    if (process.env.NODE_ENV !== 'production') {
      console.warn('Fetch appears unhandled - you are likely missing the NetworkManager middleware');
      console.warn('See https://resthooks.io/docs/guides/redux#indextsx for hooking up redux');
    }
    return state;
  }
  return {
    ...state,
    optimistic: [...state.optimistic, receiveAction]
  };
}

function invalidateReducer(state, action) {
  const results = {
    ...state.results
  };
  const meta = {
    ...state.meta
  };
  const invalidateKey = key => {
    delete results[key];
    const itemMeta = {
      ...meta[key],
      expiresAt: 0,
      invalidated: true
    };
    delete itemMeta.error;
    meta[key] = itemMeta;
  };
  if (action.type === INVALIDATE_TYPE) {
    invalidateKey(action.meta.key);
  } else {
    Object.keys(results).forEach(key => {
      if (action.testKey(key)) {
        invalidateKey(key);
      }
    });
  }
  return {
    ...state,
    results,
    meta
  };
}

function setReducer(state, action, controller) {
  if (action.error) {
    return reduceError(state, action, action.payload);
  }
  try {
    var _state$meta$action$me;
    let payload;
    // for true receives payload is contained in action
    if (action.type === OPTIMISTIC_TYPE) {
      // this should never happen
      if (!action.endpoint.getOptimisticResponse) return state;
      try {
        // compute optimistic response based on current state
        payload = action.endpoint.getOptimisticResponse.call(action.endpoint, controller.snapshot(state, action.meta.fetchedAt), ...action.meta.args);
      } catch (e) {
        var _e$constructor;
        // AbortOptimistic means 'do nothing', otherwise we count the exception as endpoint failure
        if (((_e$constructor = e.constructor) == null ? void 0 : _e$constructor.name) === 'AbortOptimistic') {
          return state;
        }
        throw e;
      }
    } else {
      payload = action.payload;
    }
    const {
      result,
      entities,
      indexes,
      entityMeta
    } = normalizr.normalize(payload, action.endpoint.schema, action.meta.args, state.entities, state.indexes, state.entityMeta, action.meta);
    const results = {
      ...state.results,
      [action.meta.key]: result
    };
    try {
      if (action.endpoint.update) {
        const updaters = action.endpoint.update(result, ...action.meta.args);
        Object.keys(updaters).forEach(key => {
          results[key] = updaters[key](results[key]);
        });
      }
      // no reason to completely fail because of user-code error
      // integrity of this state update is still guaranteed
    } catch (error) {
      console.error(`The following error occured during Endpoint.update() for ${action.meta.key}`);
      console.error(error);
    }
    return {
      entities,
      indexes,
      results,
      entityMeta,
      meta: {
        ...state.meta,
        [action.meta.key]: {
          date: action.meta.date,
          expiresAt: action.meta.expiresAt,
          prevExpiresAt: (_state$meta$action$me = state.meta[action.meta.key]) == null ? void 0 : _state$meta$action$me.expiresAt
        }
      },
      optimistic: filterOptimistic(state, action),
      lastReset: state.lastReset
    };
    // reducer must update the state, so in case of processing errors we simply compute the results inline
  } catch (error) {
    if (typeof error === 'object') {
      error.message = `Error processing ${action.meta.key}\n\nFull Schema: ${JSON.stringify(action.endpoint.schema, undefined, 2)}\n\nError:\n${error.message}`;
      if ('payload' in action) error.payload = action.payload;
      error.status = 400;
    }

    // this is not always bubbled up, so let's double sure this doesn't fail silently
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      console.error(error);
    }
    return reduceError(state, action, error);
  }
}
function reduceError(state, action, error) {
  if (error.name === 'AbortError') {
    // In case we abort simply undo the optimistic update and act like no fetch even occured
    // We still want those watching promises from fetch directly to observed the abort, but we don't want to
    // Trigger errors in this case. This means theoretically improperly built abortes useResource() could suspend forever.
    return {
      ...state,
      optimistic: filterOptimistic(state, action)
    };
  }
  return {
    ...state,
    meta: {
      ...state.meta,
      [action.meta.key]: {
        date: action.meta.date,
        error,
        expiresAt: action.meta.expiresAt,
        errorPolicy: action.endpoint.errorPolicy == null ? void 0 : action.endpoint.errorPolicy(error)
      }
    },
    optimistic: filterOptimistic(state, action)
  };
}
/** Filter all requests with same serialization that did not start after the resolving request */
function filterOptimistic(state, resolvingAction) {
  return state.optimistic.filter(optimisticAction => optimisticAction.meta.key !== resolvingAction.meta.key || (optimisticAction.type === OPTIMISTIC_TYPE ? optimisticAction.meta.fetchedAt !== resolvingAction.meta.fetchedAt : optimisticAction.meta.date > resolvingAction.meta.date));
}

function createReducer(controller) {
  return function reducer(state, action) {
    if (!state) state = initialState;
    switch (action.type) {
      case GC_TYPE:
        // inline deletes are fine as these should have 0 refcounts
        action.entities.forEach(([key, pk]) => {
          var _entities$key, _entityMeta$key;
          (_entities$key = state.entities[key]) == null ? true : delete _entities$key[pk];
          (_entityMeta$key = state.entityMeta[key]) == null ? true : delete _entityMeta$key[pk];
        });
        action.results.forEach(fetchKey => {
          delete state.results[fetchKey];
          delete state.meta[fetchKey];
        });
        return state;
      case FETCH_TYPE:
        return fetchReducer(state, action);
      case OPTIMISTIC_TYPE:
      // eslint-disable-next-line no-fallthrough
      case SET_TYPE:
        return setReducer(state, action, controller);
      case INVALIDATEALL_TYPE:
      case INVALIDATE_TYPE:
        return invalidateReducer(state, action);
      case EXPIREALL_TYPE:
        return expireReducer(state, action);
      case RESET_TYPE:
        return {
          ...initialState,
          lastReset: action.date
        };
      default:
        // A reducer must always return a valid state.
        // Alternatively you can throw an error if an invalid action is dispatched.
        return state;
    }
  };
}
const initialState = {
  entities: {},
  indexes: {},
  results: {},
  meta: {},
  entityMeta: {},
  optimistic: [],
  lastReset: 0
};

var internal = /*#__PURE__*/Object.freeze({
  __proto__: null,
  inferResults: normalizr.inferResults,
  DELETED: normalizr.DELETED,
  INVALID: normalizr.INVALID,
  RIC: RIC$1,
  initialState: initialState
});

function createExpireAll(testKey) {
  return {
    type: EXPIREALL_TYPE,
    testKey
  };
}

/**
 * Requesting a fetch to begin
 */
function createFetch(endpoint, {
  args
}) {
  const key = endpoint.key(...args);
  let resolve = 0;
  let reject = 0;
  const promise = new Promise((a, b) => {
    [resolve, reject] = [a, b];
  });
  const meta = {
    args,
    key,
    throttle: !endpoint.sideEffect,
    resolve,
    reject,
    promise,
    createdAt: Date.now(),
    nm: false
  };
  return {
    type: FETCH_TYPE,
    payload: () => endpoint(...args),
    meta,
    endpoint
  };
}

function createInvalidate(endpoint, {
  args
}) {
  return {
    type: INVALIDATE_TYPE,
    meta: {
      key: endpoint.key(...args)
    }
  };
}

function createInvalidateAll(testKey) {
  return {
    type: INVALIDATEALL_TYPE,
    testKey
  };
}

function createReset() {
  return {
    type: RESET_TYPE,
    date: Date.now()
  };
}

const ensurePojo =
// FormData doesn't exist in node
/* istanbul ignore else we don't run coverage when we test node*/
typeof FormData !== 'undefined' ? body => body instanceof FormData ? Object.fromEntries(body.entries()) : body : /* istanbul ignore next */
body => body;
var ensurePojo$1 = ensurePojo;

function createSet(endpoint, {
  args,
  fetchedAt,
  response,
  error = false
}) {
  var _endpoint$errorExpiry, _endpoint$dataExpiryL;
  const expiryLength = error ? (_endpoint$errorExpiry = endpoint.errorExpiryLength) != null ? _endpoint$errorExpiry : 1000 : (_endpoint$dataExpiryL = endpoint.dataExpiryLength) != null ? _endpoint$dataExpiryL : 60000;
  /* istanbul ignore next */
  if (process.env.NODE_ENV === 'development' && expiryLength < 0) {
    throw new Error('Negative expiry length are not allowed.');
  }
  const now = Date.now();
  const meta = {
    args: args.map(ensurePojo$1),
    fetchedAt: fetchedAt != null ? fetchedAt : now,
    date: now,
    expiresAt: now + expiryLength,
    key: endpoint.key(...args)
  };
  const action = {
    type: SET_TYPE,
    payload: response,
    endpoint: endpoint,
    meta
  };
  if (error) action.error = true;
  return action;
}

function createSubscription(endpoint, {
  args
}) {
  return {
    type: SUBSCRIBE_TYPE,
    endpoint,
    meta: {
      args,
      key: endpoint.key(...args)
    }
  };
}
function createUnsubscription(endpoint, {
  args
}) {
  return {
    type: UNSUBSCRIBE_TYPE,
    endpoint,
    meta: {
      args,
      key: endpoint.key(...args)
    }
  };
}

function selectMeta(state, fetchKey) {
  return state.meta[fetchKey];
}

const unsetDispatch = action => {
  throw new Error(`Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.`);
};
const unsetState = () => {
  // This is only the value until it is set by the CacheProvider
  /* istanbul ignore next */
  return initialState;
};

/**
 * Imperative control of Rest Hooks store
 * @see https://resthooks.io/docs/api/Controller
 */
class Controller {
  /**
   * Dispatches an action to Rest Hooks reducer.
   *
   * @see https://resthooks.io/docs/api/Controller#dispatch
   */

  /**
   * Gets the latest state snapshot that is fully committed.
   *
   * This can be useful for imperative use-cases like event handlers.
   * This should *not* be used to render; instead useSuspense() or useCache()
   * @see https://resthooks.io/docs/api/Controller#getState
   */

  constructor({
    dispatch = unsetDispatch,
    getState = unsetState,
    globalCache = {
      entities: {},
      results: {}
    }
  } = {}) {
    /*************** Action Dispatchers ***************/
    /**
     * Fetches the endpoint with given args, updating the Rest Hooks cache with the response or error upon completion.
     * @see https://resthooks.io/docs/api/Controller#fetch
     */
    this.fetch = (endpoint, ...args) => {
      const action = createFetch(endpoint, {
        args
      });
      this.dispatch(action);
      if (endpoint.schema) {
        return action.meta.promise.then(input => normalizr.denormalize(input, endpoint.schema, {}, args));
      }
      return action.meta.promise;
    };
    /**
     * Fetches only if endpoint is considered 'stale'; otherwise returns undefined
     * @see https://dataclient.io/docs/api/Controller#fetchIfStale
     */
    this.fetchIfStale = (endpoint, ...args) => {
      const {
        data,
        expiresAt,
        expiryStatus
      } = this.getResponse(endpoint, ...args, this.getState());
      if (expiryStatus !== normalizr.ExpiryStatus.Invalid && Date.now() <= expiresAt) return data;
      return this.fetch(endpoint, ...args);
    };
    /**
     * Forces refetching and suspense on useSuspense with the same Endpoint and parameters.
     * @see https://resthooks.io/docs/api/Controller#invalidate
     */
    this.invalidate = (endpoint, ...args) => args[0] !== null ? this.dispatch(createInvalidate(endpoint, {
      args: args
    })) : Promise.resolve();
    /**
     * Forces refetching and suspense on useSuspense on all matching endpoint result keys.
     * @see https://resthooks.io/docs/api/Controller#invalidateAll
     * @returns Promise that resolves when invalidation is commited.
     */
    this.invalidateAll = options => this.dispatch(createInvalidateAll(key => options.testKey(key)));
    /**
     * Sets all matching endpoint result keys to be STALE.
     * @see https://dataclient.io/docs/api/Controller#expireAll
     * @returns Promise that resolves when expiry is commited. *NOT* fetch promise
     */
    this.expireAll = options => this.dispatch(createExpireAll(key => options.testKey(key)));
    /**
     * Resets the entire Rest Hooks cache. All inflight requests will not resolve.
     * @see https://resthooks.io/docs/api/Controller#resetEntireStore
     */
    this.resetEntireStore = () => this.dispatch(createReset());
    /**
     * Stores response in cache for given Endpoint and args.
     * @see https://resthooks.io/docs/api/Controller#set
     */
    this.setResponse = (endpoint, ...rest) => {
      const response = rest[rest.length - 1];
      const action = createSet(endpoint, {
        args: rest.slice(0, rest.length - 1),
        response
      });
      return this.dispatch(action);
    };
    /**
     * @deprecated use https://resthooks.io/docs/api/Controller#setResponse instead
     */
    /* istanbul ignore next */
    this.receive = (endpoint, ...rest) => {
      /* istanbul ignore next */
      return this.setResponse(endpoint, ...rest);
    };
    /**
     * Stores the result of Endpoint and args as the error provided.
     * @see https://resthooks.io/docs/api/Controller#setError
     */
    this.setError = (endpoint, ...rest) => {
      const response = rest[rest.length - 1];
      const action = createSet(endpoint, {
        args: rest.slice(0, rest.length - 1),
        response,
        error: true
      });
      return this.dispatch(action);
    };
    /**
     * Another name for setError
     * @deprecated use https://resthooks.io/docs/api/Controller#setError instead
     */
    /* istanbul ignore next */
    this.receiveError = (endpoint, ...rest) => {
      /* istanbul ignore next */
      return this.setError(endpoint, ...rest);
    };
    /**
     * Resolves an inflight fetch. `fetchedAt` should `fetch`'s `createdAt`
     * @see https://resthooks.io/docs/api/Controller#resolve
     */
    this.resolve = (endpoint, meta) => {
      return this.dispatch(createSet(endpoint, meta));
    };
    /**
     * Marks a new subscription to a given Endpoint.
     * @see https://resthooks.io/docs/api/Controller#subscribe
     */
    this.subscribe = (endpoint, ...args) => args[0] !== null ? this.dispatch(createSubscription(endpoint, {
      args: args
    })) : Promise.resolve();
    /**
     * Marks completion of subscription to a given Endpoint.
     * @see https://resthooks.io/docs/api/Controller#unsubscribe
     */
    this.unsubscribe = (endpoint, ...args) => args[0] !== null ? this.dispatch(createUnsubscription(endpoint, {
      args: args
    })) : Promise.resolve();
    /*************** More ***************/
    /* TODO:
    abort = <E extends EndpointInterface>(
      endpoint: E,
      ...args: readonly [...Parameters<E>]
    ): Promise<void>
    */
    /**
     * Gets a snapshot (https://resthooks.io/docs/api/Snapshot)
     * @see https://resthooks.io/docs/api/Controller#snapshot
     */
    this.snapshot = (state, fetchedAt) => {
      return new Snapshot(this, state, fetchedAt);
    };
    /**
     * Gets the error, if any, for a given endpoint. Returns undefined for no errors.
     * @see https://resthooks.io/docs/api/Controller#getError
     */
    this.getError = (endpoint, ...rest) => {
      if (rest[0] === null) return;
      const state = rest[rest.length - 1];
      // this is typescript generics breaking
      const args = rest.slice(0, rest.length - 1);
      const key = endpoint.key(...args);
      const meta = selectMeta(state, key);
      const results = state.results[key];
      if (results !== undefined && (meta == null ? void 0 : meta.errorPolicy) === 'soft') return;
      return meta == null ? void 0 : meta.error;
    };
    /**
     * Gets the (globally referentially stable) response for a given endpoint/args pair from state given.
     * @see https://resthooks.io/docs/api/Controller#getResponse
     */
    this.getResponse = (endpoint, ...rest) => {
      const state = rest[rest.length - 1];
      // this is typescript generics breaking
      const args = rest.slice(0, rest.length - 1).map(ensurePojo$1);
      const isActive = args.length !== 1 || args[0] !== null;
      const key = isActive ? endpoint.key(...args) : '';
      const cacheResults = isActive ? state.results[key] : undefined;
      const schema = endpoint.schema;
      const meta = selectMeta(state, key);
      let expiresAt = meta == null ? void 0 : meta.expiresAt;
      let invalidResults = false;
      let results;
      if (cacheResults === undefined && endpoint.schema !== undefined) {
        results = normalizr.inferResults(endpoint.schema, args, state.indexes, state.entities);
        invalidResults = !normalizr.validateInference(results);
        if (!expiresAt && invalidResults) expiresAt = 1;
      } else {
        results = cacheResults;
      }
      if (!isActive) {
        return {
          data: results,
          expiryStatus: normalizr.ExpiryStatus.Valid,
          expiresAt: Infinity
        };
      }
      if (!endpoint.schema || !schemaHasEntity(endpoint.schema)) {
        return {
          data: results,
          expiryStatus: meta != null && meta.invalidated ? normalizr.ExpiryStatus.Invalid : cacheResults && !endpoint.invalidIfStale ? normalizr.ExpiryStatus.Valid : normalizr.ExpiryStatus.InvalidIfStale,
          expiresAt: expiresAt || 0
        };
      }
      if (!this.globalCache.results[key]) this.globalCache.results[key] = new normalizr.WeakEntityMap();

      // second argument is false if any entities are missing
      // eslint-disable-next-line prefer-const
      const {
        data,
        paths
      } = normalizr.denormalizeCached(results, schema, state.entities, this.globalCache.entities, this.globalCache.results[key], args);
      const invalidDenormalize = typeof data === 'symbol';

      // fallback to entity expiry time
      if (!expiresAt) {
        expiresAt = entityExpiresAt(paths, state.entityMeta);
      }

      // https://resthooks.io/docs/concepts/expiry-policy#expiry-status
      // we don't track the difference between stale or fresh because that is tied to triggering
      // conditions
      const expiryStatus = meta != null && meta.invalidated || invalidDenormalize && !(meta != null && meta.error) ? normalizr.ExpiryStatus.Invalid : invalidDenormalize || endpoint.invalidIfStale || invalidResults ? normalizr.ExpiryStatus.InvalidIfStale : normalizr.ExpiryStatus.Valid;
      return {
        data,
        expiryStatus,
        expiresAt
      };
    };
    this.dispatch = dispatch;
    this.getState = getState;
    this.globalCache = globalCache;
  }
}

// benchmark: https://www.measurethat.net/Benchmarks/Show/24691/0/min-reducer-vs-imperative-with-paths
// earliest expiry dictates age
function entityExpiresAt(paths, entityMeta) {
  let expiresAt = Infinity;
  for (const {
    pk,
    key
  } of paths) {
    var _entityMeta$key, _entityMeta$key$pk;
    const entityExpiry = (_entityMeta$key = entityMeta[key]) == null ? void 0 : (_entityMeta$key$pk = _entityMeta$key[pk]) == null ? void 0 : _entityMeta$key$pk.expiresAt;
    // expiresAt will always resolve to false with any comparison
    if (entityExpiry < expiresAt) expiresAt = entityExpiry;
  }
  return expiresAt;
}

/** Determine whether the schema has any entities.
 *
 * Without entities, denormalization is not needed, and results should not be inferred.
 */
function schemaHasEntity(schema) {
  if (normalizr.isEntity(schema)) return true;
  if (Array.isArray(schema)) return schema.length !== 0 && schemaHasEntity(schema[0]);
  if (schema && (typeof schema === 'object' || typeof schema === 'function')) {
    const nestedSchema = 'schema' in schema ? schema.schema : schema;
    if (typeof nestedSchema === 'function') {
      return schemaHasEntity(nestedSchema);
    }
    return Object.values(nestedSchema).some(x => schemaHasEntity(x));
  }
  return false;
}
class Snapshot {
  constructor(controller, state, fetchedAt = 0) {
    this.state = void 0;
    this.controller = void 0;
    this.fetchedAt = void 0;
    /*************** Data Access ***************/
    /** @see https://resthooks.io/docs/api/Snapshot#getResponse */
    this.getResponse = (endpoint, ...args) => {
      return this.controller.getResponse(endpoint, ...args, this.state);
    };
    /** @see https://resthooks.io/docs/api/Snapshot#getError */
    this.getError = (endpoint, ...args) => {
      return this.controller.getError(endpoint, ...args, this.state);
    };
    this.state = state;
    this.controller = controller;
    this.fetchedAt = fetchedAt;
  }
}

class ResetError extends Error {
  constructor() {
    super('Aborted due to RESET');
    this.name = 'ResetError';
  }
}

/** Handles all async network dispatches
 *
 * Dedupes concurrent requests by keeping track of all fetches in flight
 * and returning existing promises for requests already in flight.
 *
 * Interfaces with store via a redux-compatible middleware.
 *
 * @see https://dataclient.io/docs/api/NetworkManager
 */
class NetworkManager {
  constructor(dataExpiryLength = 60000, errorExpiryLength = 1000) {
    this.fetched = Object.create(null);
    this.resolvers = {};
    this.rejectors = {};
    this.fetchedAt = {};
    this.controller = new Controller();
    this.dataExpiryLength = dataExpiryLength;
    this.errorExpiryLength = errorExpiryLength;
    this.middleware = controller => {
      this.controller = controller;
      return next => action => {
        switch (action.type) {
          case FETCH_TYPE:
            this.handleFetch(action);
            // This is the only case that causes any state change
            // It's important to intercept other fetches as we don't want to trigger reducers during
            // render - so we need to stop 'readonly' fetches which can be triggered in render
            if (action.endpoint.getOptimisticResponse !== undefined && action.endpoint.sideEffect) {
              return next(action);
            }
            return Promise.resolve();
          case SET_TYPE:
            // only receive after new state is computed
            return next(action).then(() => {
              if (action.meta.key in this.fetched) {
                var _controller$getState$;
                // Note: meta *must* be set by reducer so this should be safe
                const error = (_controller$getState$ = controller.getState().meta[action.meta.key]) == null ? void 0 : _controller$getState$.error;
                // processing errors result in state meta having error, so we should reject the promise
                if (error) {
                  this.handleReceive(createSet(action.endpoint, {
                    args: action.meta.args,
                    response: error,
                    fetchedAt: action.meta.fetchedAt,
                    error: true
                  }));
                } else {
                  this.handleReceive(action);
                }
              }
            });
          case RESET_TYPE:
            {
              const rejectors = {
                ...this.rejectors
              };
              this.clearAll();
              return next(action).then(() => {
                // there could be external listeners to the promise
                // this must happen after commit so our own rejector knows not to dispatch an error based on this
                for (const k in rejectors) {
                  rejectors[k](new ResetError());
                }
              });
            }
          default:
            return next(action);
        }
      };
    };
  }

  /** Used by DevtoolsManager to determine whether to log an action */
  skipLogging(action) {
    /* istanbul ignore next */
    return action.type === FETCH_TYPE && action.meta.key in this.fetched;
  }

  /** On mount */
  init() {
    delete this.cleanupDate;
  }

  /** Ensures all promises are completed by rejecting remaining. */
  cleanup() {
    // ensure no dispatches after unmount
    // this must be reversible (done in init) so useEffect() remains symmetric
    this.cleanupDate = Date.now();
  }
  allSettled() {
    const fetches = Object.values(this.fetched);
    if (fetches.length) return Promise.allSettled(fetches);
  }

  /** Clear all promise state */
  clearAll() {
    for (const k in this.rejectors) {
      this.clear(k);
    }
  }

  /** Clear promise state for a given key */
  clear(key) {
    this.fetched[key].catch(() => {});
    delete this.resolvers[key];
    delete this.rejectors[key];
    delete this.fetched[key];
    delete this.fetchedAt[key];
  }
  getLastReset() {
    if (this.cleanupDate) return this.cleanupDate;
    return this.controller.getState().lastReset;
  }

  /** Called when middleware intercepts 'rest-hooks/fetch' action.
   *
   * Will then start a promise for a key and potentially start the network
   * fetch.
   *
   * Uses throttle only when instructed by action meta. This is valuable
   * for ensures mutation requests always go through.
   */
  handleFetch(action) {
    const fetch = action.payload;
    const {
      key,
      throttle,
      resolve,
      reject,
      createdAt
    } = action.meta;
    const deferedFetch = () => {
      let promise = fetch();
      const resolvePromise = promise => promise.then(data => {
        resolve(data);
        return data;
      }).catch(error => {
        reject(error);
        throw error;
      });
      // schedule non-throttled resolutions in a microtask before receive
      // this enables users awaiting their fetch to trigger any react updates needed to deal
      // with upcoming changes because of the fetch (for instance avoiding suspense if something is deleted)
      if (!throttle) {
        promise = resolvePromise(promise);
      }
      promise = promise.then(data => {
        let lastReset = this.getLastReset();

        /* istanbul ignore else */
        if (process.env.NODE_ENV !== 'production' && isNaN(lastReset)) {
          console.error('state.lastReset is NaN. Only positive timestamps are valid.');
          lastReset = 0;
        }

        // don't update state with promises started before last clear
        if (createdAt >= lastReset) {
          this.controller.resolve(action.endpoint, {
            args: action.meta.args,
            response: data,
            fetchedAt: createdAt
          });
        }
        return data;
      }).catch(error => {
        const lastReset = this.getLastReset();
        // don't update state with promises started before last clear
        if (createdAt >= lastReset) {
          this.controller.resolve(action.endpoint, {
            args: action.meta.args,
            response: error,
            fetchedAt: createdAt,
            error: true
          });
        }
        throw error;
      });
      return promise;
    };
    if (throttle) {
      return this.throttle(key, deferedFetch, createdAt).then(data => resolve(data)).catch(error => reject(error));
    } else {
      return deferedFetch().catch(() => {});
    }
  }

  /** Called when middleware intercepts a receive action.
   *
   * Will resolve the promise associated with receive key.
   */
  handleReceive(action) {
    // this can still turn out to be untrue since this is async
    if (action.meta.key in this.fetched) {
      let promiseHandler;
      if (action.error) {
        promiseHandler = this.rejectors[action.meta.key];
      } else {
        promiseHandler = this.resolvers[action.meta.key];
      }
      promiseHandler(action.payload);
      // since we're resolved we no longer need to keep track of this promise
      this.clear(action.meta.key);
    }
  }

  /** Attaches NetworkManager to store
   *
   * Intercepts 'rest-hooks/fetch' actions to start requests.
   *
   * Resolve/rejects a request when matching 'rest-hooks/receive' event
   * is seen.
   */
  getMiddleware() {
    return this.middleware;
  }

  /** Ensures only one request for a given key is in flight at any time
   *
   * Uses key to either retrieve in-flight promise, or if not
   * create a new promise and call fetch.
   *
   * Note: The new promise is not actually tied to fetch at all,
   * but is resolved when the expected 'recieve' action is processed.
   * This ensures promises are resolved only once their data is processed
   * by the reducer.
   */
  throttle(key, fetch, createdAt) {
    const lastReset = this.getLastReset();
    // we're already fetching so reuse the promise
    // fetches after reset do not count
    if (key in this.fetched && this.fetchedAt[key] > lastReset) {
      return this.fetched[key];
    }
    this.fetched[key] = new Promise((resolve, reject) => {
      this.resolvers[key] = resolve;
      this.rejectors[key] = reject;
    });
    this.fetchedAt[key] = createdAt;

    // since our real promise is resolved via the wrapReducer(),
    // we should just stop all errors here.
    // TODO: decouple this from useFetcher() (that's what's dispatching the error the resolves in here)
    RIC$1(() => {
      fetch().catch(() => null);
    }, {
      timeout: 500
    });
    return this.fetched[key];
  }
}

function applyManager(managers, controller) {
  return managers.map(manager => {
    const middleware = manager.getMiddleware();
    // TODO(breaking): remove this once controller prop is no longer supported
    return ({
      dispatch,
      getState
    }) => {
      controller.dispatch = dispatch;
      controller.getState = getState;
      // this is needed for backwards compatibility as we added 'controller' prop previously
      const API = Object.create(controller, {
        controller: {
          value: controller
        }
      });
      // controller is a superset of the middleware API
      return middleware(API);
    };
  });
}

/* These should be compatible with redux */

var newActions = /*#__PURE__*/Object.freeze({
  __proto__: null
});

class BrowserConnectionListener {
  isOnline() {
    if (navigator.onLine !== undefined) {
      return navigator.onLine;
    }
    return true;
  }
  addOnlineListener(handler) {
    addEventListener('online', handler);
  }
  removeOnlineListener(handler) {
    removeEventListener('online', handler);
  }
  addOfflineListener(handler) {
    addEventListener('offline', handler);
  }
  removeOfflineListener(handler) {
    removeEventListener('offline', handler);
  }
}
class AlwaysOnlineConnectionListener {
  isOnline() {
    /* istanbul ignore next */
    return true;
  }
  addOnlineListener() {}
  removeOnlineListener() {}
  addOfflineListener() {}
  removeOfflineListener() {}
}
let DefaultConnectionListener;
/* istanbul ignore if */
if (typeof navigator !== 'undefined' && typeof addEventListener === 'function') {
  DefaultConnectionListener = BrowserConnectionListener;
} else {
  /* istanbul ignore next */
  DefaultConnectionListener = AlwaysOnlineConnectionListener;
}
var DefaultConnectionListener$1 = DefaultConnectionListener;

/**
 * PollingSubscription keeps a given resource updated by
 * dispatching a fetch at a rate equal to the minimum update
 * interval requested.
 *
 * @see https://dataclient.io/docs/api/PollingSubscription
 */
class PollingSubscription {
  constructor(action, controller, connectionListener) {
    this.frequencyHistogram = new Map();
    /** What happens when browser goes offline */
    this.offlineListener = () => {
      // this clears existing listeners, so no need to clear offline listener
      this.cleanup();
      this.connectionListener.addOnlineListener(this.onlineListener);
    };
    /** What happens when browser comes online */
    this.onlineListener = () => {
      this.connectionListener.removeOnlineListener(this.onlineListener);
      const now = Date.now();
      this.startId = setTimeout(() => {
        if (this.startId) {
          delete this.startId;
          this.update();
          this.run();
        } else if (process.env.NODE_ENV !== 'production') {
          console.warn(`Poll setTimeout for ${this.key} still running, but timeoutId deleted`);
        }
      }, Math.max(0, this.lastFetchTime() - now + this.frequency));
      this.connectionListener.addOfflineListener(this.offlineListener);
    };
    if (action.endpoint.pollFrequency === undefined) throw new Error('frequency needed for polling subscription');
    this.endpoint = action.endpoint;
    this.frequency = action.endpoint.pollFrequency;
    this.args = action.meta.args;
    this.key = action.meta.key;
    this.frequencyHistogram.set(this.frequency, 1);
    this.controller = controller;
    this.connectionListener = connectionListener || new DefaultConnectionListener$1();

    // Kickstart running since this is initialized after the online notif is sent
    if (this.connectionListener.isOnline()) {
      this.onlineListener();
    } else {
      this.offlineListener();
    }
  }

  /** Subscribe to a frequency */
  add(frequency) {
    if (frequency === undefined) return;
    if (this.frequencyHistogram.has(frequency)) {
      this.frequencyHistogram.set(frequency, this.frequencyHistogram.get(frequency) + 1);
    } else {
      this.frequencyHistogram.set(frequency, 1);

      // new min so restart service
      if (frequency < this.frequency) {
        this.frequency = frequency;
        this.run();
      }
    }
  }

  /** Unsubscribe from a frequency */
  remove(frequency) {
    if (frequency === undefined) return false;
    if (this.frequencyHistogram.has(frequency)) {
      this.frequencyHistogram.set(frequency, this.frequencyHistogram.get(frequency) - 1);
      if (this.frequencyHistogram.get(frequency) < 1) {
        this.frequencyHistogram.delete(frequency);

        // nothing subscribed to this anymore...it is invalid
        if (this.frequencyHistogram.size === 0) {
          this.cleanup();
          return true;
        }

        // this was the min, so find the next size
        if (frequency <= this.frequency) {
          this.frequency = Math.min(...this.frequencyHistogram.keys());
          this.run();
        }
      }
    } /* istanbul ignore next */else if (process.env.NODE_ENV !== 'production') {
      console.error(`Mismatched remove: ${frequency} is not subscribed for ${this.key}`);
    }
    return false;
  }

  /** Cleanup means clearing out background interval. */
  cleanup() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      delete this.intervalId;
    }
    if (this.lastIntervalId) {
      clearInterval(this.lastIntervalId);
      delete this.lastIntervalId;
    }
    if (this.startId) {
      clearTimeout(this.startId);
      delete this.startId;
    }
    this.connectionListener.removeOnlineListener(this.onlineListener);
    this.connectionListener.removeOfflineListener(this.offlineListener);
  }

  /** Trigger request for latest resource */
  update() {
    const sup = this.endpoint;
    const endpoint = function (...args) {
      return sup.call(this, ...args);
    };
    Object.assign(endpoint, this.endpoint);
    endpoint.dataExpiryLength = this.frequency / 2;
    endpoint.errorExpiryLength = this.frequency / 10;
    endpoint.errorPolicy = () => 'soft';
    endpoint.key = () => this.key;
    // stop any errors here from bubbling
    this.controller.fetch(endpoint, ...this.args).catch(() => null);
  }
  /** Run polling process with current frequency
   *
   * Will clean up old poll interval on next run
   */
  run() {
    if (this.startId) return;
    if (this.intervalId) this.lastIntervalId = this.intervalId;
    this.intervalId = setInterval(() => {
      // since we don't know how long into the last poll it was before resetting
      // we wait til the next fetch to clear old intervals
      if (this.lastIntervalId) {
        clearInterval(this.lastIntervalId);
        delete this.lastIntervalId;
      }
      if (this.intervalId) this.update();else if (process.env.NODE_ENV !== 'production') {
        console.warn(`Poll intervalId for ${this.key} still running, but intervalId deleted`);
      }
    }, this.frequency);
  }

  /** Last fetch time */
  lastFetchTime() {
    var _this$controller$getS, _this$controller$getS2;
    return (_this$controller$getS = (_this$controller$getS2 = this.controller.getState().meta[this.key]) == null ? void 0 : _this$controller$getS2.date) != null ? _this$controller$getS : 0;
  }
}

/** Interface handling a single resource subscription */

/** The static class that constructs Subscription */

/** Handles subscription actions -> fetch or receive actions
 *
 * Constructor takes a SubscriptionConstructable class to control how
 * subscriptions are handled. (e.g., polling, websockets)
 *
 * @see https://dataclient.io/docs/api/SubscriptionManager
 */
class SubscriptionManager {
  constructor(Subscription) {
    this.subscriptions = {};
    this.controller = new Controller();
    this.Subscription = Subscription;
    this.middleware = controller => {
      this.controller = controller;
      return next => action => {
        switch (action.type) {
          case SUBSCRIBE_TYPE:
            try {
              this.handleSubscribe(action);
            } catch (e) {
              console.error(e);
            }
            return Promise.resolve();
          case UNSUBSCRIBE_TYPE:
            this.handleUnsubscribe(action);
            return Promise.resolve();
          default:
            return next(action);
        }
      };
    };
  }

  /** Ensures all subscriptions are cleaned up. */
  cleanup() {
    for (const key in this.subscriptions) {
      this.subscriptions[key].cleanup();
    }
  }

  /** Called when middleware intercepts 'rest-hooks/subscribe' action.
   *
   */
  handleSubscribe(action) {
    const key = action.meta.key;
    if (key in this.subscriptions) {
      const frequency = action.endpoint.pollFrequency;
      this.subscriptions[key].add(frequency);
    } else {
      this.subscriptions[key] = new this.Subscription(action, this.controller);
    }
  }

  /** Called when middleware intercepts 'rest-hooks/unsubscribe' action.
   *
   */
  handleUnsubscribe(action) {
    const key = action.meta.key;

    /* istanbul ignore else */
    if (key in this.subscriptions) {
      const frequency = action.endpoint.pollFrequency;
      const empty = this.subscriptions[key].remove(frequency);
      if (empty) {
        delete this.subscriptions[key];
      }
    } else if (process.env.NODE_ENV !== 'production') {
      console.error(`Mismatched unsubscribe: ${key} is not subscribed`);
    }
  }

  /** Attaches Manager to store
   *
   * Intercepts 'rest-hooks/subscribe'/'rest-hooks/unsubscribe' to register resources that
   * need to be kept up to date.
   *
   * Will possibly dispatch 'rest-hooks/fetch' or 'rest-hooks/receive' to keep resources fresh
   *
   */
  getMiddleware() {
    return this.middleware;
  }
}

var _globalThis$document;
const HASINTL = typeof Intl !== 'undefined';
const DEFAULT_CONFIG = {
  name: `Rest Hooks: ${(_globalThis$document = globalThis.document) == null ? void 0 : _globalThis$document.title}`,
  autoPause: true,
  serialize: {
    options: undefined,
    /* istanbul ignore next */
    replacer: HASINTL ? (key, value) => {
      if (typeof value === 'number' && typeof key === 'string' && isFinite(value) && (key === 'date' || key.endsWith('At'))) {
        return Intl.DateTimeFormat('en-US', {
          hour: 'numeric',
          minute: 'numeric',
          second: 'numeric',
          fractionalSecondDigits: 3
        }).format(value);
      }
      return value;
    } : undefined
  }
};

/** Integrates with https://github.com/reduxjs/redux-devtools
 *
 * Options: https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md
 *
 * @see https://dataclient.io/docs/api/DevToolsManager
 */
class DevToolsManager {
  constructor(config, skipLogging) {
    /* istanbul ignore next */
    this.devTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__.connect({
      ...DEFAULT_CONFIG,
      config
    });

    /* istanbul ignore if */
    /* istanbul ignore next */
    if (this.devTools) {
      this.middleware = controller => {
        const reducer = createReducer(controller);
        return next => action => {
          const ret = next(action);
          ret.then(() => {
            if (skipLogging != null && skipLogging(action)) return;
            const state = controller.getState();
            this.devTools.send(action, state.optimistic.reduce(reducer, state), undefined, 'REST_HOOKS');
          });
          return ret;
        };
      };
    } else {
      this.middleware = () => next => action => next(action);
    }
  }

  /** Called when initial state is ready */
  init(state) {
    /* istanbul ignore if */
    if (this.devTools) this.devTools.init(state);
  }

  /** Ensures all subscriptions are cleaned up. */
  cleanup() {}

  /** Attaches Manager to store
   *
   */
  getMiddleware() {
    return this.middleware;
  }
}

/** Handling network unauthorized indicators like HTTP 401
 *
 * @see https://dataclient.io/docs/api/LogoutManager
 */
class LogoutManager {
  constructor({
    handleLogout,
    shouldLogout
  } = {}) {
    if (handleLogout) this.handleLogout = handleLogout;
    if (shouldLogout) this.shouldLogout = shouldLogout;
    this.middleware = controller => next => async action => {
      await next(action);
      if (action.type === SET_TYPE && action.error && this.shouldLogout(action.payload)) {
        this.handleLogout(controller);
      }
    };
  }
  cleanup() {}
  getMiddleware() {
    return this.middleware;
  }
  shouldLogout(error) {
    // 401 indicates reauthorization is needed
    return error.status === 401;
  }
  handleLogout(controller) {
    controller.resetEntireStore();
  }
}

// this further restricts the types to be future compatible

Object.hasOwn = Object.hasOwn || /* istanbul ignore next */function hasOwn(it, key) {
  return Object.prototype.hasOwnProperty.call(it, key);
};

Object.defineProperty(exports, 'ExpiryStatus', {
  enumerable: true,
  get: function () { return normalizr.ExpiryStatus; }
});
exports.Controller = Controller;
exports.DefaultConnectionListener = DefaultConnectionListener$1;
exports.DevToolsManager = DevToolsManager;
exports.LogoutManager = LogoutManager;
exports.NetworkManager = NetworkManager;
exports.PollingSubscription = PollingSubscription;
exports.ResetError = ResetError;
exports.SubscriptionManager = SubscriptionManager;
exports.__INTERNAL__ = internal;
exports.actionTypes = actionTypes;
exports.applyManager = applyManager;
exports.createFetch = createFetch;
exports.createReceive = createSet;
exports.createReducer = createReducer;
exports.initialState = initialState;
exports.newActions = newActions;
