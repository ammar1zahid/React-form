import { expireReducer } from './expireReducer.js';
import { fetchReducer } from './fetchReducer.js';
import { invalidateReducer } from './invalidateReducer.js';
import { setReducer } from './setReducer.js';
import { SET_TYPE, INVALIDATE_TYPE, RESET_TYPE, FETCH_TYPE, GC_TYPE, OPTIMISTIC_TYPE, INVALIDATEALL_TYPE, EXPIREALL_TYPE } from '../../actionTypes.js';
export default function createReducer(controller) {
  return function reducer(state, action) {
    if (!state) state = initialState;
    switch (action.type) {
      case GC_TYPE:
        // inline deletes are fine as these should have 0 refcounts
        action.entities.forEach(([key, pk]) => {
          var _entities$key, _entityMeta$key;
          (_entities$key = state.entities[key]) == null ? true : delete _entities$key[pk];
          (_entityMeta$key = state.entityMeta[key]) == null ? true : delete _entityMeta$key[pk];
        });
        action.results.forEach(fetchKey => {
          delete state.results[fetchKey];
          delete state.meta[fetchKey];
        });
        return state;
      case FETCH_TYPE:
        return fetchReducer(state, action);
      case OPTIMISTIC_TYPE:
      // eslint-disable-next-line no-fallthrough
      case SET_TYPE:
        return setReducer(state, action, controller);
      case INVALIDATEALL_TYPE:
      case INVALIDATE_TYPE:
        return invalidateReducer(state, action);
      case EXPIREALL_TYPE:
        return expireReducer(state, action);
      case RESET_TYPE:
        return {
          ...initialState,
          lastReset: action.date
        };
      default:
        // A reducer must always return a valid state.
        // Alternatively you can throw an error if an invalid action is dispatched.
        return state;
    }
  };
}
export const initialState = {
  entities: {},
  indexes: {},
  results: {},
  meta: {},
  entityMeta: {},
  optimistic: [],
  lastReset: 0
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJleHBpcmVSZWR1Y2VyIiwiZmV0Y2hSZWR1Y2VyIiwiaW52YWxpZGF0ZVJlZHVjZXIiLCJzZXRSZWR1Y2VyIiwiU0VUX1RZUEUiLCJJTlZBTElEQVRFX1RZUEUiLCJSRVNFVF9UWVBFIiwiRkVUQ0hfVFlQRSIsIkdDX1RZUEUiLCJPUFRJTUlTVElDX1RZUEUiLCJJTlZBTElEQVRFQUxMX1RZUEUiLCJFWFBJUkVBTExfVFlQRSIsImNyZWF0ZVJlZHVjZXIiLCJjb250cm9sbGVyIiwicmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwiaW5pdGlhbFN0YXRlIiwidHlwZSIsImVudGl0aWVzIiwiZm9yRWFjaCIsImtleSIsInBrIiwiX2VudGl0aWVzJGtleSIsIl9lbnRpdHlNZXRhJGtleSIsImVudGl0eU1ldGEiLCJyZXN1bHRzIiwiZmV0Y2hLZXkiLCJtZXRhIiwibGFzdFJlc2V0IiwiZGF0ZSIsImluZGV4ZXMiLCJvcHRpbWlzdGljIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3N0YXRlL3JlZHVjZXIvY3JlYXRlUmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleHBpcmVSZWR1Y2VyIH0gZnJvbSAnLi9leHBpcmVSZWR1Y2VyLmpzJztcbmltcG9ydCB7IGZldGNoUmVkdWNlciB9IGZyb20gJy4vZmV0Y2hSZWR1Y2VyLmpzJztcbmltcG9ydCB7IGludmFsaWRhdGVSZWR1Y2VyIH0gZnJvbSAnLi9pbnZhbGlkYXRlUmVkdWNlci5qcyc7XG5pbXBvcnQgeyBzZXRSZWR1Y2VyIH0gZnJvbSAnLi9zZXRSZWR1Y2VyLmpzJztcbmltcG9ydCB7XG4gIFNFVF9UWVBFLFxuICBJTlZBTElEQVRFX1RZUEUsXG4gIFJFU0VUX1RZUEUsXG4gIEZFVENIX1RZUEUsXG4gIEdDX1RZUEUsXG4gIE9QVElNSVNUSUNfVFlQRSxcbiAgSU5WQUxJREFURUFMTF9UWVBFLFxuICBFWFBJUkVBTExfVFlQRSxcbn0gZnJvbSAnLi4vLi4vYWN0aW9uVHlwZXMuanMnO1xuaW1wb3J0IHR5cGUgQ29udHJvbGxlciBmcm9tICcuLi8uLi9jb250cm9sbGVyL0NvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb25UeXBlcywgU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXIoY29udHJvbGxlcjogQ29udHJvbGxlcik6IFJlZHVjZXJUeXBlIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlZHVjZXIoXG4gICAgc3RhdGU6IFN0YXRlPHVua25vd24+IHwgdW5kZWZpbmVkLFxuICAgIGFjdGlvbjogQWN0aW9uVHlwZXMsXG4gICk6IFN0YXRlPHVua25vd24+IHtcbiAgICBpZiAoIXN0YXRlKSBzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICBjYXNlIEdDX1RZUEU6XG4gICAgICAgIC8vIGlubGluZSBkZWxldGVzIGFyZSBmaW5lIGFzIHRoZXNlIHNob3VsZCBoYXZlIDAgcmVmY291bnRzXG4gICAgICAgIGFjdGlvbi5lbnRpdGllcy5mb3JFYWNoKChba2V5LCBwa10pID0+IHtcbiAgICAgICAgICBkZWxldGUgKHN0YXRlIGFzIGFueSkuZW50aXRpZXNba2V5XT8uW3BrXTtcbiAgICAgICAgICBkZWxldGUgKHN0YXRlIGFzIGFueSkuZW50aXR5TWV0YVtrZXldPy5bcGtdO1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aW9uLnJlc3VsdHMuZm9yRWFjaChmZXRjaEtleSA9PiB7XG4gICAgICAgICAgZGVsZXRlIChzdGF0ZSBhcyBhbnkpLnJlc3VsdHNbZmV0Y2hLZXldO1xuICAgICAgICAgIGRlbGV0ZSAoc3RhdGUgYXMgYW55KS5tZXRhW2ZldGNoS2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIGNhc2UgRkVUQ0hfVFlQRTpcbiAgICAgICAgcmV0dXJuIGZldGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgY2FzZSBPUFRJTUlTVElDX1RZUEU6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGNhc2UgU0VUX1RZUEU6XG4gICAgICAgIHJldHVybiBzZXRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIGNvbnRyb2xsZXIpO1xuXG4gICAgICBjYXNlIElOVkFMSURBVEVBTExfVFlQRTpcbiAgICAgIGNhc2UgSU5WQUxJREFURV9UWVBFOlxuICAgICAgICByZXR1cm4gaW52YWxpZGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG5cbiAgICAgIGNhc2UgRVhQSVJFQUxMX1RZUEU6XG4gICAgICAgIHJldHVybiBleHBpcmVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuXG4gICAgICBjYXNlIFJFU0VUX1RZUEU6XG4gICAgICAgIHJldHVybiB7IC4uLmluaXRpYWxTdGF0ZSwgbGFzdFJlc2V0OiBhY3Rpb24uZGF0ZSB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBBIHJlZHVjZXIgbXVzdCBhbHdheXMgcmV0dXJuIGEgdmFsaWQgc3RhdGUuXG4gICAgICAgIC8vIEFsdGVybmF0aXZlbHkgeW91IGNhbiB0aHJvdyBhbiBlcnJvciBpZiBhbiBpbnZhbGlkIGFjdGlvbiBpcyBkaXNwYXRjaGVkLlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9IGFzIGFueTtcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRpYWxTdGF0ZTogU3RhdGU8dW5rbm93bj4gPSB7XG4gIGVudGl0aWVzOiB7fSxcbiAgaW5kZXhlczoge30sXG4gIHJlc3VsdHM6IHt9LFxuICBtZXRhOiB7fSxcbiAgZW50aXR5TWV0YToge30sXG4gIG9wdGltaXN0aWM6IFtdLFxuICBsYXN0UmVzZXQ6IDAsXG59O1xuXG50eXBlIFJlZHVjZXJUeXBlID0gKFxuICBzdGF0ZTogU3RhdGU8dW5rbm93bj4gfCB1bmRlZmluZWQsXG4gIGFjdGlvbjogQWN0aW9uVHlwZXMsXG4pID0+IFN0YXRlPHVua25vd24+O1xuXG50eXBlIFdyaXRhYmxlPFQ+ID0geyBbUCBpbiBrZXlvZiBUXTogTm9uTnVsbGFibGU8V3JpdGFibGU8VFtQXT4+IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGFBQWEsUUFBUSxvQkFBb0I7QUFDbEQsU0FBU0MsWUFBWSxRQUFRLG1CQUFtQjtBQUNoRCxTQUFTQyxpQkFBaUIsUUFBUSx3QkFBd0I7QUFDMUQsU0FBU0MsVUFBVSxRQUFRLGlCQUFpQjtBQUM1QyxTQUNFQyxRQUFRLEVBQ1JDLGVBQWUsRUFDZkMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsZUFBZSxFQUNmQyxrQkFBa0IsRUFDbEJDLGNBQWMsUUFDVCxzQkFBc0I7QUFJN0IsZUFBZSxTQUFTQyxhQUFhQSxDQUFDQyxVQUFzQixFQUFlO0VBQ3pFLE9BQU8sU0FBU0MsT0FBT0EsQ0FDckJDLEtBQWlDLEVBQ2pDQyxNQUFtQixFQUNIO0lBQ2hCLElBQUksQ0FBQ0QsS0FBSyxFQUFFQSxLQUFLLEdBQUdFLFlBQVk7SUFDaEMsUUFBUUQsTUFBTSxDQUFDRSxJQUFJO01BQ2pCLEtBQUtWLE9BQU87UUFDVjtRQUNBUSxNQUFNLENBQUNHLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLENBQUMsQ0FBQ0MsR0FBRyxFQUFFQyxFQUFFLENBQUMsS0FBSztVQUFBLElBQUFDLGFBQUEsRUFBQUMsZUFBQTtVQUNyQyxDQUFBRCxhQUFBLEdBQVFSLEtBQUssQ0FBU0ksUUFBUSxDQUFDRSxHQUFHLENBQUMsbUJBQW5DLE9BQU9FLGFBQUEsQ0FBK0JELEVBQUUsQ0FBQztVQUN6QyxDQUFBRSxlQUFBLEdBQVFULEtBQUssQ0FBU1UsVUFBVSxDQUFDSixHQUFHLENBQUMsbUJBQXJDLE9BQU9HLGVBQUEsQ0FBaUNGLEVBQUUsQ0FBQztRQUM3QyxDQUFDLENBQUM7UUFDRk4sTUFBTSxDQUFDVSxPQUFPLENBQUNOLE9BQU8sQ0FBQ08sUUFBUSxJQUFJO1VBQ2pDLE9BQVFaLEtBQUssQ0FBU1csT0FBTyxDQUFDQyxRQUFRLENBQUM7VUFDdkMsT0FBUVosS0FBSyxDQUFTYSxJQUFJLENBQUNELFFBQVEsQ0FBQztRQUN0QyxDQUFDLENBQUM7UUFDRixPQUFPWixLQUFLO01BQ2QsS0FBS1IsVUFBVTtRQUNiLE9BQU9OLFlBQVksQ0FBQ2MsS0FBSyxFQUFFQyxNQUFNLENBQUM7TUFFcEMsS0FBS1AsZUFBZTtNQUNwQjtNQUNBLEtBQUtMLFFBQVE7UUFDWCxPQUFPRCxVQUFVLENBQUNZLEtBQUssRUFBRUMsTUFBTSxFQUFFSCxVQUFVLENBQUM7TUFFOUMsS0FBS0gsa0JBQWtCO01BQ3ZCLEtBQUtMLGVBQWU7UUFDbEIsT0FBT0gsaUJBQWlCLENBQUNhLEtBQUssRUFBRUMsTUFBTSxDQUFDO01BRXpDLEtBQUtMLGNBQWM7UUFDakIsT0FBT1gsYUFBYSxDQUFDZSxLQUFLLEVBQUVDLE1BQU0sQ0FBQztNQUVyQyxLQUFLVixVQUFVO1FBQ2IsT0FBTztVQUFFLEdBQUdXLFlBQVk7VUFBRVksU0FBUyxFQUFFYixNQUFNLENBQUNjO1FBQUssQ0FBQztNQUVwRDtRQUNFO1FBQ0E7UUFDQSxPQUFPZixLQUFLO0lBQ2hCO0VBQ0YsQ0FBQztBQUNIO0FBRUEsT0FBTyxNQUFNRSxZQUE0QixHQUFHO0VBQzFDRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO0VBQ1pZLE9BQU8sRUFBRSxDQUFDLENBQUM7RUFDWEwsT0FBTyxFQUFFLENBQUMsQ0FBQztFQUNYRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0VBQ1JILFVBQVUsRUFBRSxDQUFDLENBQUM7RUFDZE8sVUFBVSxFQUFFLEVBQUU7RUFDZEgsU0FBUyxFQUFFO0FBQ2IsQ0FBQyJ9