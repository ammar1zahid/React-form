import Controller from '../controller/Controller.js';
import type { FetchAction, Manager, ActionTypes, Middleware, SetAction } from '../types.js';
export declare class ResetError extends Error {
    name: string;
    constructor();
}
/** Handles all async network dispatches
 *
 * Dedupes concurrent requests by keeping track of all fetches in flight
 * and returning existing promises for requests already in flight.
 *
 * Interfaces with store via a redux-compatible middleware.
 *
 * @see https://dataclient.io/docs/api/NetworkManager
 */
export default class NetworkManager implements Manager {
    protected fetched: {
        [k: string]: Promise<any>;
    };
    protected resolvers: {
        [k: string]: (value?: any) => void;
    };
    protected rejectors: {
        [k: string]: (value?: any) => void;
    };
    protected fetchedAt: {
        [k: string]: number;
    };
    readonly dataExpiryLength: number;
    readonly errorExpiryLength: number;
    protected middleware: Middleware;
    protected controller: Controller;
    cleanupDate?: number;
    constructor(dataExpiryLength?: number, errorExpiryLength?: number);
    /** Used by DevtoolsManager to determine whether to log an action */
    skipLogging(action: ActionTypes): boolean;
    /** On mount */
    init(): void;
    /** Ensures all promises are completed by rejecting remaining. */
    cleanup(): void;
    allSettled(): Promise<PromiseSettledResult<any>[]> | undefined;
    /** Clear all promise state */
    protected clearAll(): void;
    /** Clear promise state for a given key */
    protected clear(key: string): void;
    protected getLastReset(): number;
    /** Called when middleware intercepts 'rest-hooks/fetch' action.
     *
     * Will then start a promise for a key and potentially start the network
     * fetch.
     *
     * Uses throttle only when instructed by action meta. This is valuable
     * for ensures mutation requests always go through.
     */
    protected handleFetch(action: FetchAction): Promise<any>;
    /** Called when middleware intercepts a receive action.
     *
     * Will resolve the promise associated with receive key.
     */
    protected handleReceive(action: SetAction): void;
    /** Attaches NetworkManager to store
     *
     * Intercepts 'rest-hooks/fetch' actions to start requests.
     *
     * Resolve/rejects a request when matching 'rest-hooks/receive' event
     * is seen.
     */
    getMiddleware(): Middleware;
    /** Ensures only one request for a given key is in flight at any time
     *
     * Uses key to either retrieve in-flight promise, or if not
     * create a new promise and call fetch.
     *
     * Note: The new promise is not actually tied to fetch at all,
     * but is resolved when the expected 'recieve' action is processed.
     * This ensures promises are resolved only once their data is processed
     * by the reducer.
     */
    protected throttle(key: string, fetch: () => Promise<any>, createdAt: number): Promise<any>;
}
//# sourceMappingURL=NetworkManager.d.ts.map