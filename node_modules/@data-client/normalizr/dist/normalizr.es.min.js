class e{constructor(){this.localCache={}}getEntity(e,t,n,r){const i=t.key;i in this.localCache||(this.localCache[i]=Object.create(null));const o=this.localCache[i];return o[e]||r(o),o[e]}getResults(e,t,n){return{data:n(),paths:[]}}}const t=Symbol("INVALID");function n(e){return null!==e&&void 0!==e.pk}const r=e=>{if("production"!==process.env.NODE_ENV){if(Array.isArray(e)&&e.length>1)throw new Error(`Expected schema definition to be a single schema, but found ${e.length}.`)}return e[0]},i=e=>void 0!==e&&"symbol"!=typeof e,o=(e,t,n,i,o,s,c,a,l)=>{e=r(e);const u=(e=>Array.isArray(e)?e:Object.keys(e).map((t=>e[t])))(t);return u.map(((t,r)=>o(t,n,i,e,s,c,a,l)))},s=(e,t,n,o)=>(e=r(e),t.map?t.map((t=>o(t,e))).filter(i):t);function c(e,t,n,r){}function a(e){return!("function"!=typeof e.hasOwnProperty||!(Object.hasOwnProperty.call(e,"__ownerID")||e._map&&Object.hasOwnProperty.call(e._map,"__ownerID")))}const l=(e,t,n,r,i,o,s,c,a)=>{const l=Object.assign({},t);return Object.keys(e).forEach((n=>{const r=e[n],u=i(t[n],t,n,r,o,s,c,a);null==u?delete l[n]:l[n]=u})),l},u=(e,n,r,i)=>{if(a(n))return function(e,n,r,i){let o=!1;const s=Object.keys(e).reduce(((t,n)=>{const r=`${n}`,s=i(t.get(r),e[r]);return"symbol"==typeof s&&(o=!0),t.has(r)?t.set(r,s):t}),n);return o?t:s}(e,n,0,i);const o=Object.assign({},n);let s=!1;return Object.keys(e).forEach((t=>{const n=i(o[t],e[t]);void 0!==o[t]&&(o[t]=n),"symbol"==typeof n&&(s=!0)})),s?t:o};function h(e,t,n,r,i){const o={};for(const s of Object.keys(e))o[s]=r(e[s],t,n,i);return o}function d(e,n,r,i,o,s){let c,l,u;n.createIfValid?c=o[i]=a(e)?n.createIfValid(e.toObject()):n.createIfValid(e):(c=e,r=function(e){const t=e.og||e,n=(e,n)=>t(e,n);return n.og=e,n}(r),r.setLocal=e=>o[i]=e),void 0===c?o[i]=t:"function"==typeof n.denormalizeOnly?o[i]=n.denormalizeOnly(c,s,r):([o[i],l,u]=n.denormalize(c,r),u&&(o[i]=t))}var f=(e,r,i)=>{const o=function(e){return function(t,n){var r;const i="AllSchema"===(null==n||null==(r=n.constructor)?void 0:r.name),o=e(t,n);return i?["symbol"==typeof o?void 0:o,"symbol"!=typeof o,!1]:["symbol"==typeof o?void 0:o,!0,"symbol"==typeof o]}}(c);function c(l,h){if(!h)return l;if(null===l)return l;const f="function"==typeof h.denormalize||"function"==typeof h.denormalizeOnly;if(!f&&"function"==typeof h)return l instanceof h||void 0===l?l:new h(l);if(void 0===l){var y;return"AllSchema"===(null==(y=h.constructor)?void 0:y.name)?t:void 0}if(!f&&"object"==typeof h){return(Array.isArray(h)?s:u)(h,l,i,c)}return n(h)?function(e,n,r,i,o,s){const c="object"==typeof e?e:o({key:n.key,pk:e});if("symbol"==typeof c){if("function"==typeof n.denormalizeOnly)return n.denormalizeOnly(c,r,i);if(c.toString().includes("DELETED"))return t}if("object"!=typeof c||null===c)return c;const l="string"==typeof e?e:n.pk(a(c)?c.toJS():c,void 0,void 0,r);return void 0===l||""===l||"undefined"===l?function(e){const t={};return e(t),t[""]}((e=>d(c,n,i,"",e,r))):s.getEntity(l,n,c,(e=>d(c,n,i,l,e,r)))}(l,h,i,h.denormalizeOnly?c:o,e,r):f?h.denormalizeOnly?h.denormalizeOnly(l,i,c):function(e,n,r){const[i,o,s]=e.denormalize(n,r),c=!Object.hasOwn(e,"normalize")&&Object.hasOwn(e,"denormalize")&&Object.hasOwn(e,"infer");return s&&!c?t:i}(h,l,o):l}return(e,t)=>{const n=Object(e)===e&&Object(t)===t;return r.getResults(e,n,(()=>c(e,t)))}};class y{constructor(){this.next=new WeakMap,this.nextPath=void 0}get(e,t){let n=this.next.get(e);if(!n)return p;for(;n.nextPath;){const e=t(n.nextPath);if(n=n.next.get(e),!n)return p}return[n.value,n.journey]}set(e,t){if(e.length<1)throw new b;let n=this;for(const{entity:t,path:r}of e){let e=n.next.get(t);e||(e=new v,n.next.set(t,e)),n.nextPath=r,n=e}n.nextPath=void 0,n.value=t,n.journey=g(e)}}const p=[void 0,void 0];function m(e){return a(e)?({key:t,pk:n})=>e.getIn([t,n]):({key:t,pk:n})=>{var r;return null==(r=e[t])?void 0:r[n]}}function g(e){var t;const n=e.map((e=>e.path));return""===(null==(t=n[0])?void 0:t.pk)&&n.shift(),n}class v{constructor(){this.next=new WeakMap,this.value=void 0,this.journey=[],this.nextPath=void 0}}class b extends Error{constructor(...e){super(...e),this.message="Keys must include at least one member"}}function O(t,n,r,i=[]){return void 0===n||void 0===t?t:f(m(r),new e,i)(t,n).data}class x{constructor(e,t,n){this.dependencies=[],this.cycleCache={},this.cycleIndex=-1,this.localCache={},this._getEntity=e,this.getCache=j(t),this.resultCache=n}getEntity(e,t,n,r){const i=t.key,{localCacheKey:o,cycleCacheKey:s}=this.getCacheKey(i);if(o[e])e in s?this.cycleIndex=s[e]:this.dependencies.push({entity:n,path:{key:i,pk:e}});else{const c=this.getCache(e,t),[a,l]=c.get(n,this._getEntity);if(l)return o[e]=a.value,this.dependencies.push(...a.dependencies),a.value;{const t=this.dependencies.length;s[e]=t,this.dependencies.push({entity:n,path:{key:i,pk:e}}),r(o),delete s[e];const a=this.dependencies.slice(-1===this.cycleIndex?t:this.cycleIndex),l={dependencies:a,value:o[e]};c.set(a,l),this.cycleIndex===t&&(this.cycleIndex=-1)}}return o[e]}getCacheKey(e){e in this.localCache||(this.localCache[e]=Object.create(null)),e in this.cycleCache||(this.cycleCache[e]=Object.create(null));return{localCacheKey:this.localCache[e],cycleCacheKey:this.cycleCache[e]}}getResults(e,t,n){if(!t)return{data:n(),paths:this.paths()};let[r,i]=this.resultCache.get(e,this._getEntity);return void 0===i&&(r=n(),i=this.paths(),this.dependencies.unshift({entity:e,path:{key:"",pk:""}}),this.resultCache.set(this.dependencies,r)),{data:r,paths:i}}paths(){return g(this.dependencies)}}const j=e=>(t,n)=>{var r;const i=n.key,o=null!=(r=n.cacheWith)?r:n;i in e||(e[i]=Object.create(null));const s=e[i];s[t]||(s[t]=new WeakMap);let c=s[t].get(o);return c||(c=new y,s[t].set(o,c)),c};function k(e,t,n,r={},i=new y,o=[]){if(void 0===t)return{data:e,paths:[]};if(void 0===e)return{data:void 0,paths:[]};const s=m(n);return f(s,new x(s,r,i),o)(e,t)}const w=Symbol("ENTITY WAS DELETED"),A=(e,t,n,r,i,s,c,a)=>{if(!e||!r)return e;if(r.normalize&&"function"==typeof r.normalize)return"object"!=typeof e?e:r.normalize(e,t,n,A,i,s,c,a);if("function"==typeof r)return new r(e);if("object"!=typeof e||"object"!=typeof r)return e;return(Array.isArray(r)?o:l)(r,e,t,n,A,i,s,c,a)},E=(e,t,n,r,i,o)=>(s,c,a)=>{const l=s.key;l in e||(e[l]={},n[l]=Object.assign({},n[l]),i[l]=Object.assign({},i[l]));const u=e[l][a];if(u)e[l][a]=s.merge(u,c);else{const t=n[l][a];let r;t&&(r=i[l][a])?(e[l][a]=s.mergeWithStore?s.mergeWithStore(r,o,t,c):function(e,t,n,r,i){const o=e.useIncoming&&n.fetchedAt?e.useIncoming(t,n,r,i):t.date<=n.date;return o?typeof i!=typeof r?i:e.merge(r,i):r}(s,r,o,t,c),i[l][a]=s.mergeMetaWithStore?s.mergeMetaWithStore(r,o,t,c):function(e,t,n,r,i){return{expiresAt:Math.max(e.expiresAt?e.expiresAt(n,i):n.expiresAt,t.expiresAt),date:Math.max(n.date,t.date),fetchedAt:Math.max(n.fetchedAt,t.fetchedAt)}}(s,r,o,0,c)):(e[l][a]=c,i[l][a]={expiresAt:s.expiresAt?s.expiresAt(o,c):o.expiresAt,date:o.date,fetchedAt:o.fetchedAt})}s.indexes&&(l in t||(t[l]={},r[l]=Object.assign({},r[l])),function(e,t,n,r,i,o){for(const s of t){s in n||(r[s]=n[s]={});const t=n[s];o[e]&&delete t[o[e][s]],o&&o[e]&&o[e][s]!==i[s]&&(t[o[e][s]]=w),s in i?t[i[s]]=e:"production"!==process.env.NODE_ENV&&console.warn(`Index not found in entity. Indexes must be top-level members of your entity.\nIndex: ${s}\nEntity: ${JSON.stringify(i,void 0,2)}`)}}(a,s.indexes,t[l],r[l],e[l][a],n[l])),n[l][a]=e[l][a]};const I=(e,t,n=[],r={},i={},o={},s={date:Date.now(),expiresAt:1/0,fetchedAt:0})=>{if(null==t)return{entities:r,indexes:i,result:e,entityMeta:o};const c=function(e){return["object","function"].includes(typeof e)?"object":typeof e}(t);if(null===e||typeof e!==c&&(void 0===t.key||void 0!==t.pk||"string"!=typeof e)){if("production"!==process.env.NODE_ENV){const n=e=>{try{return"string"!=typeof JSON.parse(e)}catch(e){return!1}};throw"string"==typeof e&&n(e)?new Error(`Normalizing a string, but this does match schema.\n\nParsing this input string as JSON worked. This likely indicates fetch function did not parse\nthe JSON. By default, this only happens if "content-type" header includes "json".\nSee https://resthooks.io/rest/api/RestEndpoint#parseResponse for more information\n\n  Schema: ${JSON.stringify(t,void 0,2)}\n  Input: "${e}"`):new Error(`Unexpected input given to normalize. Expected type to be "${c}", found "${null===e?"null":typeof e}".\n\n          Schema: ${JSON.stringify(t,void 0,2)}\n          Input: "${e}"`)}throw new Error(`Unexpected input given to normalize. Expected type to be "${c}", found "${null===e?"null":typeof e}".`)}const a=Object.assign({},r),l=Object.assign({},i),u=Object.assign({},o),h=E({},{},a,l,u,s);return{entities:a,indexes:l,result:A(e,e,void 0,t,h,{},r,n),entityMeta:u}};function C(e,t,r,i){if(function(e){return!!e&&"function"==typeof e.infer}(e)){var o;const s=e.infer(t,r,C,i);if(n(e)&&void 0!==s&&(null==(o=i[e.key])||!o[s]))return;return s}if("object"==typeof e&&e){return(Array.isArray(e)?c:h)(e,t,r,C,i)}return e}function z(e){return void 0!==e&&(!(e&&"object"==typeof e&&!Array.isArray(e))||Object.values(e).every(z))}var S={Invalid:1,InvalidIfStale:2,Valid:3};Object.hasOwn=Object.hasOwn||function(e,t){return Object.prototype.hasOwnProperty.call(e,t)};export{w as DELETED,S as ExpiryStatus,t as INVALID,y as WeakEntityMap,O as denormalize,k as denormalizeCached,C as inferResults,n as isEntity,I as normalize,z as validateInference};
