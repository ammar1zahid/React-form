var data_client_normalizr = (function (exports) {
  'use strict';

  class LocalCache {
    constructor() {
      this.localCache = {};
    }
    getEntity(pk, schema, entity, computeValue) {
      const key = schema.key;
      if (!(key in this.localCache)) {
        this.localCache[key] = Object.create(null);
      }
      const localCacheKey = this.localCache[key];
      if (!localCacheKey[pk]) {
        computeValue(localCacheKey);
      }
      return localCacheKey[pk];
    }
    getResults(input, cachable, computeValue) {
      return {
        data: computeValue(),
        paths: []
      };
    }
  }

  const INVALID = Symbol('INVALID');

  function isEntity(schema) {
    return schema !== null && schema.pk !== undefined;
  }

  const validateSchema = definition => {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      const isArray = Array.isArray(definition);
      if (isArray && definition.length > 1) {
        throw new Error(`Expected schema definition to be a single schema, but found ${definition.length}.`);
      }
    }
    return definition[0];
  };
  const getValues = input => Array.isArray(input) ? input : Object.keys(input).map(key => input[key]);
  const filterEmpty = item => item !== undefined && typeof item !== 'symbol';
  const normalize$2 = (schema, input, parent, key, visit, addEntity, visitedEntities, storeEntities, args) => {
    schema = validateSchema(schema);
    const values = getValues(input);

    // Special case: Arrays pass *their* parent on to their children, since there
    // is not any special information that can be gathered from themselves directly
    return values.map((value, index) => visit(value, parent, key, schema, addEntity, visitedEntities, storeEntities, args));
  };
  const denormalize$3 = (schema, input, args, unvisit) => {
    schema = validateSchema(schema);
    return input.map ? input.map(entityOrId => unvisit(entityOrId, schema)).filter(filterEmpty) : input;
  };
  function infer$1(schema, args, indexes, recurse) {
    return undefined;
  }

  /**
   * Helpers to enable Immutable compatibility *without* bringing in
   * the 'immutable' package as a dependency.
   */

  /**
   * Check if an object is immutable by checking if it has a key specific
   * to the immutable library.
   *
   * @param  {any} object
   * @return {bool}
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  function isImmutable(object) {
    return !!(typeof object.hasOwnProperty === 'function' && (Object.hasOwnProperty.call(object, '__ownerID') ||
    // Immutable.Map
    object._map && Object.hasOwnProperty.call(object._map, '__ownerID'))); // Immutable.Record
  }

  /**
   * Denormalize an immutable entity.
   *
   * @param  {Schema} schema
   * @param  {Immutable.Map|Immutable.Record} input
   * @param  {function} unvisit
   * @param  {function} getDenormalizedEntity
   * @return {Immutable.Map|Immutable.Record}
   */
  function denormalizeImmutable(schema, input, args, unvisit) {
    let deleted = false;
    const obj = Object.keys(schema).reduce((object, key) => {
      // Immutable maps cast keys to strings on write so we need to ensure
      // we're accessing them using string keys.
      const stringKey = `${key}`;
      const item = unvisit(object.get(stringKey), schema[stringKey]);
      if (typeof item === 'symbol') {
        deleted = true;
      }
      if (object.has(stringKey)) {
        return object.set(stringKey, item);
      } else {
        return object;
      }
    }, input);
    return deleted ? INVALID : obj;
  }

  const normalize$1 = (schema, input, parent, key, visit, addEntity, visitedEntities, storeEntities, args) => {
    const object = Object.assign({}, input);
    Object.keys(schema).forEach(key => {
      const localSchema = schema[key];
      const value = visit(input[key], input, key, localSchema, addEntity, visitedEntities, storeEntities, args);
      if (value === undefined || value === null) {
        delete object[key];
      } else {
        object[key] = value;
      }
    });
    return object;
  };
  const denormalize$2 = (schema, input, args, unvisit) => {
    if (isImmutable(input)) {
      return denormalizeImmutable(schema, input, args, unvisit);
    }
    const object = Object.assign({}, input);
    let deleted = false;
    Object.keys(schema).forEach(key => {
      const item = unvisit(object[key], schema[key]);
      if (object[key] !== undefined) {
        object[key] = item;
      }
      if (typeof item === 'symbol') {
        deleted = true;
      }
    });
    return deleted ? INVALID : object;
  };
  function infer(schema, args, indexes, recurse, entities) {
    const resultObject = {};
    for (const k of Object.keys(schema)) {
      resultObject[k] = recurse(schema[k], args, indexes, entities);
    }
    return resultObject;
  }

  function unvisitEntity(entityOrId, schema, args, unvisit, getEntity, cache) {
    const entity = typeof entityOrId === 'object' ? entityOrId : getEntity({
      key: schema.key,
      pk: entityOrId
    });
    if (typeof entity === 'symbol') {
      if (typeof schema.denormalizeOnly === 'function') {
        return schema.denormalizeOnly(entity, args, unvisit);
        // TODO(breaking): Change to this as breaking change once we only support newer entities
      } else if (entity.toString().includes('DELETED')) {
        return INVALID;
      }
    }
    if (typeof entity !== 'object' || entity === null) {
      return entity;
    }
    const pk =
    // normalize must always place a string, because pk() return value is string | undefined
    // therefore no need to check for numbers
    typeof entityOrId === 'string' ? entityOrId : schema.pk(isImmutable(entity) ? entity.toJS() : entity, undefined, undefined, args);

    // if we can't generate a working pk we cannot do cache lookups properly,
    // so simply denormalize without caching
    if (pk === undefined || pk === '' || pk === 'undefined') {
      return noCacheGetEntity(localCacheKey => unvisitEntityObject(entity, schema, unvisit, '', localCacheKey, args));
    }

    // last function computes if it is not in any caches
    return cache.getEntity(pk, schema, entity, localCacheKey => unvisitEntityObject(entity, schema, unvisit, pk, localCacheKey, args));
  }
  function noCacheGetEntity(computeValue) {
    const localCacheKey = {};
    computeValue(localCacheKey);
    return localCacheKey[''];
  }
  function unvisitEntityObject(entity, schema, unvisit, pk, localCacheKey, args) {
    let entityCopy, _, deleted;
    /* istanbul ignore else */
    if (schema.createIfValid) {
      entityCopy = localCacheKey[pk] = isImmutable(entity) ? schema.createIfValid(entity.toObject()) : schema.createIfValid(entity);
      // TODO(breaking): remove once old verions no longer supported
    } /* istanbul ignore next */else {
      entityCopy = entity;
      unvisit = withTrackedEntities(unvisit);
      unvisit.setLocal = entityCopy => localCacheKey[pk] = entityCopy;
    }
    if (entityCopy === undefined) {
      // undefined indicates we should suspense (perhaps failed validation)
      localCacheKey[pk] = INVALID;
    } else {
      if (typeof schema.denormalizeOnly === 'function') {
        localCacheKey[pk] = schema.denormalizeOnly(entityCopy, args, unvisit);
      } else {
        [localCacheKey[pk], _, deleted] = schema.denormalize(entityCopy, unvisit);
        if (deleted) localCacheKey[pk] = INVALID;
      }
    }
  }

  // TODO(breaking): remove once unused
  /* istanbul ignore next */
  function withTrackedEntities(unvisit) {
    // every time we nest, we want to unwrap back to the top.
    // this is due to only needed the next level of nested entities for lookup
    const originalUnvisit = unvisit.og || unvisit;
    const wrappedUnvisit = (input, schema) => originalUnvisit(input, schema);
    wrappedUnvisit.og = unvisit;
    return wrappedUnvisit;
  }
  const getUnvisit = (getEntity, cache, args) => {
    // TODO(breaking): This handles legacy schemas from 3.7 and below
    const unvisitAdapter = getUnvisitAdapter(unvisit);
    function unvisit(input, schema) {
      if (!schema) return input;
      if (input === null) {
        return input;
      }
      const hasDenormalize = typeof schema.denormalize === 'function' || typeof schema.denormalizeOnly === 'function';

      // deserialize fields (like Date)
      if (!hasDenormalize && typeof schema === 'function') {
        if (input instanceof schema) return input;
        if (input === undefined) return input;
        return new schema(input);
      }
      if (input === undefined) {
        var _schema$constructor;
        // TODO(breaking): Drop support for initial All version
        const isAll = ((_schema$constructor = schema.constructor) == null ? void 0 : _schema$constructor.name) === 'AllSchema';
        return isAll ? INVALID : undefined;
      }
      if (!hasDenormalize && typeof schema === 'object') {
        const method = Array.isArray(schema) ? denormalize$3 : denormalize$2;
        return method(schema, input, args, unvisit);
      }
      if (isEntity(schema)) {
        return unvisitEntity(input, schema, args, schema.denormalizeOnly ? unvisit : unvisitAdapter, getEntity, cache);
      }
      if (hasDenormalize) {
        if (schema.denormalizeOnly) {
          return schema.denormalizeOnly(input, args, unvisit);
        } else {
          return denormalizeLegacySchema(schema, input, unvisitAdapter);
        }
      }
      return input;
    }
    return (input, schema) => {
      // in the case where WeakMap cannot be used
      // this test ensures null is properly excluded from WeakMap
      const cachable = Object(input) === input && Object(schema) === schema;
      return cache.getResults(input, cachable, () => unvisit(input, schema));
    };
  };
  var getUnvisit$1 = getUnvisit;
  function denormalizeLegacySchema(schema, input, unvisitAdapter) {
    const [data, _, suspend] = schema.denormalize(input, unvisitAdapter);
    // TODO(breaking): Drop support for initial Query version
    // queryEndpoint schema only overrides 'denormalize' and 'infer'
    const isQuery = !Object.hasOwn(schema, 'normalize') && Object.hasOwn(schema, 'denormalize') && Object.hasOwn(schema, 'infer');
    return suspend && !isQuery ? INVALID : data;
  }

  // TODO(breaking): This handles legacy schemas from 3.7 and below
  function getUnvisitAdapter(unvisit) {
    return function (input, schema) {
      var _schema$constructor2;
      const isAll = (schema == null ? void 0 : (_schema$constructor2 = schema.constructor) == null ? void 0 : _schema$constructor2.name) === 'AllSchema';
      const value = unvisit(input, schema);

      // TODO(breaking): Drop support for initial All version
      if (isAll) {
        // we swap 'found' and 'suspend' because the initial Query version used 'found' to determine whether
        // it should 'process'
        return [typeof value === 'symbol' ? undefined : value, typeof value !== 'symbol', false];
      }
      return [typeof value === 'symbol' ? undefined : value, true, typeof value === 'symbol'];
    };
  }

  /** Maps entity dependencies to a value (usually their denormalized form)
   *
   * Dependencies store `Path` to enable quick traversal using only `State`
   * If *any* members of the dependency get cleaned up, so does that key/value pair get removed.
   */
  class WeakEntityMap {
    constructor() {
      this.next = new WeakMap();
      this.nextPath = undefined;
    }
    get(entity, getEntity) {
      let curLink = this.next.get(entity);
      if (!curLink) return EMPTY;
      while (curLink.nextPath) {
        const nextEntity = getEntity(curLink.nextPath);
        curLink = curLink.next.get(nextEntity);
        if (!curLink) return EMPTY;
      }
      // curLink exists, but has no path - so must have a value
      return [curLink.value, curLink.journey];
    }
    set(dependencies, value) {
      if (dependencies.length < 1) throw new KeySize();
      let curLink = this;
      for (const {
        entity,
        path
      } of dependencies) {
        let nextLink = curLink.next.get(entity);
        if (!nextLink) {
          nextLink = new Link();
          curLink.next.set(entity, nextLink);
        }
        curLink.nextPath = path;
        curLink = nextLink;
      }
      // in case there used to be more
      curLink.nextPath = undefined;
      curLink.value = value;
      // we could recompute this on get, but it would have a cost and we optimize for `get`
      curLink.journey = depToPaths(dependencies);
    }
  }
  const EMPTY = [undefined, undefined];
  function getEntities(state) {
    const entityIsImmutable = isImmutable(state);
    if (entityIsImmutable) {
      return ({
        key,
        pk
      }) => state.getIn([key, pk]);
    } else {
      return ({
        key,
        pk
      }) => {
        var _state$key;
        return (_state$key = state[key]) == null ? void 0 : _state$key[pk];
      };
    }
  }
  function depToPaths(dependencies) {
    var _paths$;
    const paths = dependencies.map(dep => dep.path);
    // the first item is the result input not an actual entity
    if (((_paths$ = paths[0]) == null ? void 0 : _paths$.pk) === '') paths.shift();
    return paths;
  }
  /** Link in a chain */
  class Link {
    constructor() {
      this.next = new WeakMap();
      this.value = undefined;
      this.journey = [];
      this.nextPath = undefined;
    }
  }
  class KeySize extends Error {
    constructor(...args) {
      super(...args);
      this.message = 'Keys must include at least one member';
    }
  }

  function denormalize$1(input, schema, entities, args = []) {
    // undefined means don't do anything
    if (schema === undefined || input === undefined) {
      return input;
    }
    return getUnvisit$1(getEntities(entities), new LocalCache(), args)(input, schema).data;
  }

  class GlobalCache {
    constructor(getEntity, entityCache, resultCache) {
      this.dependencies = [];
      this.cycleCache = {};
      this.cycleIndex = -1;
      this.localCache = {};
      this._getEntity = getEntity;
      this.getCache = getEntityCaches(entityCache);
      this.resultCache = resultCache;
    }
    getEntity(pk, schema, entity, computeValue) {
      const key = schema.key;
      const {
        localCacheKey,
        cycleCacheKey
      } = this.getCacheKey(key);
      if (!localCacheKey[pk]) {
        const globalCache = this.getCache(pk, schema);
        const [cacheValue, cachePath] = globalCache.get(entity, this._getEntity);
        // TODO: what if this just returned the deps - then we don't need to store them

        if (cachePath) {
          localCacheKey[pk] = cacheValue.value;
          // TODO: can we store the cache values instead of tracking *all* their sources?
          // this is only used for setting results cache correctly. if we got this far we will def need to set as we would have already tried getting it
          this.dependencies.push(...cacheValue.dependencies);
          return cacheValue.value;
        }
        // if we don't find in denormalize cache then do full denormalize
        else {
          const trackingIndex = this.dependencies.length;
          cycleCacheKey[pk] = trackingIndex;
          this.dependencies.push({
            entity,
            path: {
              key,
              pk
            }
          });

          /** NON-GLOBAL_CACHE CODE */
          computeValue(localCacheKey);
          /** /END NON-GLOBAL_CACHE CODE */

          delete cycleCacheKey[pk];
          // if in cycle, use the start of the cycle to track all deps
          // otherwise, we use our own trackingIndex
          const localKey = this.dependencies.slice(this.cycleIndex === -1 ? trackingIndex : this.cycleIndex);
          const cacheValue = {
            dependencies: localKey,
            value: localCacheKey[pk]
          };
          globalCache.set(localKey, cacheValue);

          // start of cycle - reset cycle detection
          if (this.cycleIndex === trackingIndex) {
            this.cycleIndex = -1;
          }
        }
      } else {
        // cycle detected
        if (pk in cycleCacheKey) {
          this.cycleIndex = cycleCacheKey[pk];
        } else {
          // with no cycle, globalCacheEntry will have already been set
          this.dependencies.push({
            entity,
            path: {
              key,
              pk
            }
          });
        }
      }
      return localCacheKey[pk];
    }
    getCacheKey(key) {
      if (!(key in this.localCache)) {
        this.localCache[key] = Object.create(null);
      }
      if (!(key in this.cycleCache)) {
        this.cycleCache[key] = Object.create(null);
      }
      const localCacheKey = this.localCache[key];
      const cycleCacheKey = this.cycleCache[key];
      return {
        localCacheKey,
        cycleCacheKey
      };
    }
    getResults(input, cachable, computeValue) {
      if (!cachable) {
        return {
          data: computeValue(),
          paths: this.paths()
        };
      }
      let [data, paths] = this.resultCache.get(input, this._getEntity);
      if (paths === undefined) {
        data = computeValue();
        // we want to do this before we add our 'input' entry
        paths = this.paths();
        // for the first entry, `path` is ignored so empty members is fine
        this.dependencies.unshift({
          entity: input,
          path: {
            key: '',
            pk: ''
          }
        });
        this.resultCache.set(this.dependencies, data);
      }
      return {
        data,
        paths
      };
    }
    paths() {
      return depToPaths(this.dependencies);
    }
  }
  const getEntityCaches = entityCache => {
    return (pk, schema) => {
      var _ref;
      const key = schema.key;
      // collections should use the entities they collect over
      // TODO: this should be based on a public interface
      const entityInstance = (_ref = schema.cacheWith) != null ? _ref : schema;
      if (!(key in entityCache)) {
        entityCache[key] = Object.create(null);
      }
      const entityCacheKey = entityCache[key];
      if (!entityCacheKey[pk]) entityCacheKey[pk] = new WeakMap();
      let wem = entityCacheKey[pk].get(entityInstance);
      if (!wem) {
        wem = new WeakEntityMap();
        entityCacheKey[pk].set(entityInstance, wem);
      }
      return wem;
    };
  };

  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  function denormalize(input, schema, entities, entityCache = {}, resultCache = new WeakEntityMap(), args = []) {
    // undefined means don't do anything
    if (schema === undefined) {
      return {
        data: input,
        paths: []
      };
    }
    if (input === undefined) {
      return {
        data: undefined,
        paths: []
      };
    }
    const getEntity = getEntities(entities);
    return getUnvisit$1(getEntity, new GlobalCache(getEntity, entityCache, resultCache), args)(input, schema);
  }

  const DELETED = Symbol('ENTITY WAS DELETED');

  var _s = $RefreshSig$();
  const visit = (value, parent, key, schema, addEntity, visitedEntities, storeEntities, args) => {
    if (!value || !schema) {
      return value;
    }
    if (schema.normalize && typeof schema.normalize === 'function') {
      if (typeof value !== 'object') return value;
      return schema.normalize(value, parent, key, visit, addEntity, visitedEntities, storeEntities, args);
    }

    // serializable
    if (typeof schema === 'function') {
      return new schema(value);
    }
    if (typeof value !== 'object' || typeof schema !== 'object') return value;
    const method = Array.isArray(schema) ? normalize$2 : normalize$1;
    return method(schema, value, parent, key, visit, addEntity, visitedEntities, storeEntities, args);
  };
  const addEntities = (entities, indexes, storeEntities, storeIndexes, storeEntityMeta, meta) => (schema, processedEntity, id) => {
    const schemaKey = schema.key;
    if (!(schemaKey in entities)) {
      entities[schemaKey] = {};
      storeEntities[schemaKey] = Object.assign({}, storeEntities[schemaKey]);
      storeEntityMeta[schemaKey] = Object.assign({}, storeEntityMeta[schemaKey]);
    }
    const existingEntity = entities[schemaKey][id];
    if (existingEntity) {
      entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);
    } else {
      const inStoreEntity = storeEntities[schemaKey][id];
      let inStoreMeta;
      // this case we already have this entity in store
      if (inStoreEntity && (inStoreMeta = storeEntityMeta[schemaKey][id])) {
        entities[schemaKey][id] = schema.mergeWithStore ? schema.mergeWithStore(inStoreMeta, meta, inStoreEntity, processedEntity) : mergeWithStore(schema, inStoreMeta, meta, inStoreEntity, processedEntity);
        storeEntityMeta[schemaKey][id] = schema.mergeMetaWithStore ? schema.mergeMetaWithStore(inStoreMeta, meta, inStoreEntity, processedEntity) : mergeMetaWithStore(schema, inStoreMeta, meta, inStoreEntity, processedEntity);
      } else {
        entities[schemaKey][id] = processedEntity;
        storeEntityMeta[schemaKey][id] = {
          // TODO(breaking): Remove schema.expiresat
          expiresAt: schema.expiresAt ? schema.expiresAt(meta, processedEntity) : meta.expiresAt,
          date: meta.date,
          fetchedAt: meta.fetchedAt
        };
      }
    }

    // update index
    if (schema.indexes) {
      if (!(schemaKey in indexes)) {
        indexes[schemaKey] = {};
        storeIndexes[schemaKey] = Object.assign({}, storeIndexes[schemaKey]);
      }
      handleIndexes(id, schema.indexes, indexes[schemaKey], storeIndexes[schemaKey], entities[schemaKey][id], storeEntities[schemaKey]);
    }
    // set this after index updates so we know what indexes to remove from
    storeEntities[schemaKey][id] = entities[schemaKey][id];
  };
  function handleIndexes(id, schemaIndexes, indexes, storeIndexes, entity, storeEntities) {
    for (const index of schemaIndexes) {
      if (!(index in indexes)) {
        storeIndexes[index] = indexes[index] = {};
      }
      const indexMap = indexes[index];
      if (storeEntities[id]) {
        delete indexMap[storeEntities[id][index]];
      }
      // entity already in cache but the index changed
      if (storeEntities && storeEntities[id] && storeEntities[id][index] !== entity[index]) {
        indexMap[storeEntities[id][index]] = DELETED;
      }
      if (index in entity) {
        indexMap[entity[index]] = id;
      } /* istanbul ignore next */else if (
      // eslint-disable-next-line no-undef
      process.env.NODE_ENV !== 'production') {
        console.warn(`Index not found in entity. Indexes must be top-level members of your entity.
Index: ${index}
Entity: ${JSON.stringify(entity, undefined, 2)}`);
      }
    }
  }

  // TODO(breaking): remove this in 1 breaking releases
  /** @deprecated use Entity.mergeStore() instead */
  function mergeWithStore(schema, existingMeta, incomingMeta, existing, incoming) {
    _s();
    const useIncoming =
    // useIncoming should not be used with legacy optimistic
    schema.useIncoming && incomingMeta.fetchedAt ? schema.useIncoming(existingMeta, incomingMeta, existing, incoming) : existingMeta.date <= incomingMeta.date;
    if (useIncoming) {
      if (typeof incoming !== typeof existing) {
        return incoming;
      } else {
        return schema.merge(existing, incoming);
      }
    } else {
      return existing;
    }
  }

  // TODO(breaking): remove this in 1 breaking releases
  /** @deprecated use Entity.mergeMetaWithStore() instead */
  _s(mergeWithStore, "RSHyr3aBwsmLX8s7SwDQGEQTEhQ=", false, function () {
    return [schema.useIncoming];
  });
  function mergeMetaWithStore(schema, existingMeta, incomingMeta, existing, incoming) {
    return {
      expiresAt: Math.max(schema.expiresAt ? schema.expiresAt(incomingMeta, incoming) : incomingMeta.expiresAt, existingMeta.expiresAt),
      date: Math.max(incomingMeta.date, existingMeta.date),
      fetchedAt: Math.max(incomingMeta.fetchedAt, existingMeta.fetchedAt)
    };
  }
  function expectedSchemaType(schema) {
    return ['object', 'function'].includes(typeof schema) ? 'object' : typeof schema;
  }

  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  const normalize = (input, schema, args = [], storeEntities = {}, storeIndexes = {}, storeEntityMeta = {}, meta = {
    date: Date.now(),
    expiresAt: Infinity,
    fetchedAt: 0
  }) => {
    // no schema means we don't process at all
    if (schema === undefined || schema === null) return {
      entities: storeEntities,
      indexes: storeIndexes,
      result: input,
      entityMeta: storeEntityMeta
    };
    const schemaType = expectedSchemaType(schema);
    if (input === null || typeof input !== schemaType &&
    // we will allow a Delete schema to be a string or object
    !(schema.key !== undefined && schema.pk === undefined && typeof input === 'string')) {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        const parseWorks = input => {
          try {
            return typeof JSON.parse(input) !== 'string';
          } catch (e) {
            return false;
          }
        };
        if (typeof input === 'string' && parseWorks(input)) {
          throw new Error(`Normalizing a string, but this does match schema.

Parsing this input string as JSON worked. This likely indicates fetch function did not parse
the JSON. By default, this only happens if "content-type" header includes "json".
See https://resthooks.io/rest/api/RestEndpoint#parseResponse for more information

  Schema: ${JSON.stringify(schema, undefined, 2)}
  Input: "${input}"`);
        } else {
          throw new Error(`Unexpected input given to normalize. Expected type to be "${schemaType}", found "${input === null ? 'null' : typeof input}".

          Schema: ${JSON.stringify(schema, undefined, 2)}
          Input: "${input}"`);
        }
      } else {
        throw new Error(`Unexpected input given to normalize. Expected type to be "${schemaType}", found "${input === null ? 'null' : typeof input}".`);
      }
    }
    const newEntities = {};
    const newIndexes = {};
    const entities = Object.assign({}, storeEntities);
    const indexes = Object.assign({}, storeIndexes);
    const entityMeta = Object.assign({}, storeEntityMeta);
    const addEntity = addEntities(newEntities, newIndexes, entities, indexes, entityMeta, meta);
    const visitedEntities = {};
    const result = visit(input, input, undefined, schema, addEntity, visitedEntities, storeEntities, args);
    return {
      entities,
      indexes,
      result,
      entityMeta
    };
  };

  /**
   * Build the result parameter to denormalize from schema alone.
   * Tries to compute the entity ids from params.
   */
  function inferResults(schema, args, indexes, entities) {
    // schema classes
    if (canInfer(schema)) {
      var _entities$schema$key;
      const ret = schema.infer(args, indexes, inferResults, entities);
      // TODO(breaking): back compatibility with endpoint@3.7 and less
      if (isEntity(schema) && ret !== undefined && !((_entities$schema$key = entities[schema.key]) != null && _entities$schema$key[ret])) {
        return undefined;
      }
      return ret;
    }

    // plain case
    if (typeof schema === 'object' && schema) {
      const method = Array.isArray(schema) ? infer$1 : infer;
      return method(schema, args, indexes, inferResults, entities);
    }

    // fallback for things like null or undefined
    return schema;
  }
  function canInfer(schema) {
    return !!schema && typeof schema.infer === 'function';
  }

  // this only works if entity does a lookup first to see if its entity is 'found'
  function validateInference(results) {
    if (results === undefined) return false;
    if (results && typeof results === 'object' && !Array.isArray(results)) {
      return Object.values(results).every(validateInference);
    }
    return true;
  }

  var ExpiryStatus = {
    Invalid: 1,
    InvalidIfStale: 2,
    Valid: 3
  };
  // looser version to allow for cross-package version compatibility

  Object.hasOwn = Object.hasOwn || /* istanbul ignore next */function hasOwn(it, key) {
    return Object.prototype.hasOwnProperty.call(it, key);
  };

  exports.DELETED = DELETED;
  exports.ExpiryStatus = ExpiryStatus;
  exports.INVALID = INVALID;
  exports.WeakEntityMap = WeakEntityMap;
  exports.denormalize = denormalize$1;
  exports.denormalizeCached = denormalize;
  exports.inferResults = inferResults;
  exports.isEntity = isEntity;
  exports.normalize = normalize;
  exports.validateInference = validateInference;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
