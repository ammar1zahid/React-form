import { normalize as arrayNormalize } from './schemas/Array.js';
import { normalize as objectNormalize } from './schemas/Object.js';
import { DELETED } from './special.js';
const visit = (value, parent, key, schema, addEntity, visitedEntities, storeEntities, args) => {
  if (!value || !schema) {
    return value;
  }
  if (schema.normalize && typeof schema.normalize === 'function') {
    if (typeof value !== 'object') return value;
    return schema.normalize(value, parent, key, visit, addEntity, visitedEntities, storeEntities, args);
  }

  // serializable
  if (typeof schema === 'function') {
    return new schema(value);
  }
  if (typeof value !== 'object' || typeof schema !== 'object') return value;
  const method = Array.isArray(schema) ? arrayNormalize : objectNormalize;
  return method(schema, value, parent, key, visit, addEntity, visitedEntities, storeEntities, args);
};
const addEntities = (entities, indexes, storeEntities, storeIndexes, storeEntityMeta, meta) => (schema, processedEntity, id) => {
  const schemaKey = schema.key;
  if (!(schemaKey in entities)) {
    entities[schemaKey] = {};
    storeEntities[schemaKey] = {
      ...storeEntities[schemaKey]
    };
    storeEntityMeta[schemaKey] = {
      ...storeEntityMeta[schemaKey]
    };
  }
  const existingEntity = entities[schemaKey][id];
  if (existingEntity) {
    entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);
  } else {
    const inStoreEntity = storeEntities[schemaKey][id];
    let inStoreMeta;
    // this case we already have this entity in store
    if (inStoreEntity && (inStoreMeta = storeEntityMeta[schemaKey][id])) {
      entities[schemaKey][id] = schema.mergeWithStore ? schema.mergeWithStore(inStoreMeta, meta, inStoreEntity, processedEntity) : mergeWithStore(schema, inStoreMeta, meta, inStoreEntity, processedEntity);
      storeEntityMeta[schemaKey][id] = schema.mergeMetaWithStore ? schema.mergeMetaWithStore(inStoreMeta, meta, inStoreEntity, processedEntity) : mergeMetaWithStore(schema, inStoreMeta, meta, inStoreEntity, processedEntity);
    } else {
      entities[schemaKey][id] = processedEntity;
      storeEntityMeta[schemaKey][id] = {
        // TODO(breaking): Remove schema.expiresat
        expiresAt: schema.expiresAt ? schema.expiresAt(meta, processedEntity) : meta.expiresAt,
        date: meta.date,
        fetchedAt: meta.fetchedAt
      };
    }
  }

  // update index
  if (schema.indexes) {
    if (!(schemaKey in indexes)) {
      indexes[schemaKey] = {};
      storeIndexes[schemaKey] = {
        ...storeIndexes[schemaKey]
      };
    }
    handleIndexes(id, schema.indexes, indexes[schemaKey], storeIndexes[schemaKey], entities[schemaKey][id], storeEntities[schemaKey]);
  }
  // set this after index updates so we know what indexes to remove from
  storeEntities[schemaKey][id] = entities[schemaKey][id];
};
function handleIndexes(id, schemaIndexes, indexes, storeIndexes, entity, storeEntities) {
  for (const index of schemaIndexes) {
    if (!(index in indexes)) {
      storeIndexes[index] = indexes[index] = {};
    }
    const indexMap = indexes[index];
    if (storeEntities[id]) {
      delete indexMap[storeEntities[id][index]];
    }
    // entity already in cache but the index changed
    if (storeEntities && storeEntities[id] && storeEntities[id][index] !== entity[index]) {
      indexMap[storeEntities[id][index]] = DELETED;
    }
    if (index in entity) {
      indexMap[entity[index]] = id;
    } /* istanbul ignore next */else if (
    // eslint-disable-next-line no-undef
    process.env.NODE_ENV !== 'production') {
      console.warn(`Index not found in entity. Indexes must be top-level members of your entity.
Index: ${index}
Entity: ${JSON.stringify(entity, undefined, 2)}`);
    }
  }
}

// TODO(breaking): remove this in 1 breaking releases
/** @deprecated use Entity.mergeStore() instead */
function mergeWithStore(schema, existingMeta, incomingMeta, existing, incoming) {
  const useIncoming =
  // useIncoming should not be used with legacy optimistic
  schema.useIncoming && incomingMeta.fetchedAt ? schema.useIncoming(existingMeta, incomingMeta, existing, incoming) : existingMeta.date <= incomingMeta.date;
  if (useIncoming) {
    if (typeof incoming !== typeof existing) {
      return incoming;
    } else {
      return schema.merge(existing, incoming);
    }
  } else {
    return existing;
  }
}

// TODO(breaking): remove this in 1 breaking releases
/** @deprecated use Entity.mergeMetaWithStore() instead */
function mergeMetaWithStore(schema, existingMeta, incomingMeta, existing, incoming) {
  return {
    expiresAt: Math.max(schema.expiresAt ? schema.expiresAt(incomingMeta, incoming) : incomingMeta.expiresAt, existingMeta.expiresAt),
    date: Math.max(incomingMeta.date, existingMeta.date),
    fetchedAt: Math.max(incomingMeta.fetchedAt, existingMeta.fetchedAt)
  };
}
function expectedSchemaType(schema) {
  return ['object', 'function'].includes(typeof schema) ? 'object' : typeof schema;
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const normalize = (input, schema, args = [], storeEntities = {}, storeIndexes = {}, storeEntityMeta = {}, meta = {
  date: Date.now(),
  expiresAt: Infinity,
  fetchedAt: 0
}) => {
  // no schema means we don't process at all
  if (schema === undefined || schema === null) return {
    entities: storeEntities,
    indexes: storeIndexes,
    result: input,
    entityMeta: storeEntityMeta
  };
  const schemaType = expectedSchemaType(schema);
  if (input === null || typeof input !== schemaType &&
  // we will allow a Delete schema to be a string or object
  !(schema.key !== undefined && schema.pk === undefined && typeof input === 'string')) {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      const parseWorks = input => {
        try {
          return typeof JSON.parse(input) !== 'string';
        } catch (e) {
          return false;
        }
      };
      if (typeof input === 'string' && parseWorks(input)) {
        throw new Error(`Normalizing a string, but this does match schema.

Parsing this input string as JSON worked. This likely indicates fetch function did not parse
the JSON. By default, this only happens if "content-type" header includes "json".
See https://resthooks.io/rest/api/RestEndpoint#parseResponse for more information

  Schema: ${JSON.stringify(schema, undefined, 2)}
  Input: "${input}"`);
      } else {
        throw new Error(`Unexpected input given to normalize. Expected type to be "${schemaType}", found "${input === null ? 'null' : typeof input}".

          Schema: ${JSON.stringify(schema, undefined, 2)}
          Input: "${input}"`);
      }
    } else {
      throw new Error(`Unexpected input given to normalize. Expected type to be "${schemaType}", found "${input === null ? 'null' : typeof input}".`);
    }
  }
  const newEntities = {};
  const newIndexes = {};
  const entities = {
    ...storeEntities
  };
  const indexes = {
    ...storeIndexes
  };
  const entityMeta = {
    ...storeEntityMeta
  };
  const addEntity = addEntities(newEntities, newIndexes, entities, indexes, entityMeta, meta);
  const visitedEntities = {};
  const result = visit(input, input, undefined, schema, addEntity, visitedEntities, storeEntities, args);
  return {
    entities,
    indexes,
    result,
    entityMeta
  };
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJub3JtYWxpemUiLCJhcnJheU5vcm1hbGl6ZSIsIm9iamVjdE5vcm1hbGl6ZSIsIkRFTEVURUQiLCJ2aXNpdCIsInZhbHVlIiwicGFyZW50Iiwia2V5Iiwic2NoZW1hIiwiYWRkRW50aXR5IiwidmlzaXRlZEVudGl0aWVzIiwic3RvcmVFbnRpdGllcyIsImFyZ3MiLCJtZXRob2QiLCJBcnJheSIsImlzQXJyYXkiLCJhZGRFbnRpdGllcyIsImVudGl0aWVzIiwiaW5kZXhlcyIsInN0b3JlSW5kZXhlcyIsInN0b3JlRW50aXR5TWV0YSIsIm1ldGEiLCJwcm9jZXNzZWRFbnRpdHkiLCJpZCIsInNjaGVtYUtleSIsImV4aXN0aW5nRW50aXR5IiwibWVyZ2UiLCJpblN0b3JlRW50aXR5IiwiaW5TdG9yZU1ldGEiLCJtZXJnZVdpdGhTdG9yZSIsIm1lcmdlTWV0YVdpdGhTdG9yZSIsImV4cGlyZXNBdCIsImRhdGUiLCJmZXRjaGVkQXQiLCJoYW5kbGVJbmRleGVzIiwic2NoZW1hSW5kZXhlcyIsImVudGl0eSIsImluZGV4IiwiaW5kZXhNYXAiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwid2FybiIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJleGlzdGluZ01ldGEiLCJpbmNvbWluZ01ldGEiLCJleGlzdGluZyIsImluY29taW5nIiwidXNlSW5jb21pbmciLCJNYXRoIiwibWF4IiwiZXhwZWN0ZWRTY2hlbWFUeXBlIiwiaW5jbHVkZXMiLCJpbnB1dCIsIkRhdGUiLCJub3ciLCJJbmZpbml0eSIsInJlc3VsdCIsImVudGl0eU1ldGEiLCJzY2hlbWFUeXBlIiwicGsiLCJwYXJzZVdvcmtzIiwicGFyc2UiLCJlIiwiRXJyb3IiLCJuZXdFbnRpdGllcyIsIm5ld0luZGV4ZXMiXSwic291cmNlcyI6WyIuLi9zcmMvbm9ybWFsaXplLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRW50aXR5SW50ZXJmYWNlLCBTY2hlbWEsIE5vcm1hbGl6ZWRJbmRleCB9IGZyb20gJy4vaW50ZXJmYWNlLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZSBhcyBhcnJheU5vcm1hbGl6ZSB9IGZyb20gJy4vc2NoZW1hcy9BcnJheS5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemUgYXMgb2JqZWN0Tm9ybWFsaXplIH0gZnJvbSAnLi9zY2hlbWFzL09iamVjdC5qcyc7XG5pbXBvcnQgeyBERUxFVEVEIH0gZnJvbSAnLi9zcGVjaWFsLmpzJztcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplTnVsbGFibGUsIE5vcm1hbGl6ZWRTY2hlbWEgfSBmcm9tICcuL3R5cGVzLmpzJztcblxuY29uc3QgdmlzaXQgPSAoXG4gIHZhbHVlOiBhbnksXG4gIHBhcmVudDogYW55LFxuICBrZXk6IGFueSxcbiAgc2NoZW1hOiBhbnksXG4gIGFkZEVudGl0eTogKFxuICAgIHNjaGVtYTogRW50aXR5SW50ZXJmYWNlLFxuICAgIHByb2Nlc3NlZEVudGl0eTogYW55LFxuICAgIGlkOiBzdHJpbmcsXG4gICkgPT4gdm9pZCxcbiAgdmlzaXRlZEVudGl0aWVzOiBhbnksXG4gIHN0b3JlRW50aXRpZXM6IGFueSxcbiAgYXJnczogYW55W10sXG4pID0+IHtcbiAgaWYgKCF2YWx1ZSB8fCAhc2NoZW1hKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHNjaGVtYS5ub3JtYWxpemUgJiYgdHlwZW9mIHNjaGVtYS5ub3JtYWxpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBzY2hlbWEubm9ybWFsaXplKFxuICAgICAgdmFsdWUsXG4gICAgICBwYXJlbnQsXG4gICAgICBrZXksXG4gICAgICB2aXNpdCxcbiAgICAgIGFkZEVudGl0eSxcbiAgICAgIHZpc2l0ZWRFbnRpdGllcyxcbiAgICAgIHN0b3JlRW50aXRpZXMsXG4gICAgICBhcmdzLFxuICAgICk7XG4gIH1cblxuICAvLyBzZXJpYWxpemFibGVcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IHNjaGVtYSh2YWx1ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0JykgcmV0dXJuIHZhbHVlO1xuXG4gIGNvbnN0IG1ldGhvZCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hKSA/IGFycmF5Tm9ybWFsaXplIDogb2JqZWN0Tm9ybWFsaXplO1xuICByZXR1cm4gbWV0aG9kKFxuICAgIHNjaGVtYSxcbiAgICB2YWx1ZSxcbiAgICBwYXJlbnQsXG4gICAga2V5LFxuICAgIHZpc2l0LFxuICAgIGFkZEVudGl0eSxcbiAgICB2aXNpdGVkRW50aXRpZXMsXG4gICAgc3RvcmVFbnRpdGllcyxcbiAgICBhcmdzLFxuICApO1xufTtcblxuY29uc3QgYWRkRW50aXRpZXMgPVxuICAoXG4gICAgZW50aXRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgaW5kZXhlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICBzdG9yZUVudGl0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIHN0b3JlSW5kZXhlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICBzdG9yZUVudGl0eU1ldGE6IHtcbiAgICAgIFtlbnRpdHlLZXk6IHN0cmluZ106IHtcbiAgICAgICAgW3BrOiBzdHJpbmddOiB7XG4gICAgICAgICAgZGF0ZTogbnVtYmVyO1xuICAgICAgICAgIGV4cGlyZXNBdDogbnVtYmVyO1xuICAgICAgICAgIGZldGNoZWRBdDogbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9LFxuICAgIG1ldGE6IHsgZXhwaXJlc0F0OiBudW1iZXI7IGRhdGU6IG51bWJlcjsgZmV0Y2hlZEF0OiBudW1iZXIgfSxcbiAgKSA9PlxuICAoc2NoZW1hOiBFbnRpdHlJbnRlcmZhY2UsIHByb2Nlc3NlZEVudGl0eTogYW55LCBpZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hS2V5ID0gc2NoZW1hLmtleTtcbiAgICBpZiAoIShzY2hlbWFLZXkgaW4gZW50aXRpZXMpKSB7XG4gICAgICBlbnRpdGllc1tzY2hlbWFLZXldID0ge307XG4gICAgICBzdG9yZUVudGl0aWVzW3NjaGVtYUtleV0gPSB7IC4uLnN0b3JlRW50aXRpZXNbc2NoZW1hS2V5XSB9O1xuICAgICAgc3RvcmVFbnRpdHlNZXRhW3NjaGVtYUtleV0gPSB7IC4uLnN0b3JlRW50aXR5TWV0YVtzY2hlbWFLZXldIH07XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdFbnRpdHkgPSBlbnRpdGllc1tzY2hlbWFLZXldW2lkXTtcbiAgICBpZiAoZXhpc3RpbmdFbnRpdHkpIHtcbiAgICAgIGVudGl0aWVzW3NjaGVtYUtleV1baWRdID0gc2NoZW1hLm1lcmdlKGV4aXN0aW5nRW50aXR5LCBwcm9jZXNzZWRFbnRpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpblN0b3JlRW50aXR5ID0gc3RvcmVFbnRpdGllc1tzY2hlbWFLZXldW2lkXTtcbiAgICAgIGxldCBpblN0b3JlTWV0YToge1xuICAgICAgICBkYXRlOiBudW1iZXI7XG4gICAgICAgIGV4cGlyZXNBdDogbnVtYmVyO1xuICAgICAgICBmZXRjaGVkQXQ6IG51bWJlcjtcbiAgICAgIH07XG4gICAgICAvLyB0aGlzIGNhc2Ugd2UgYWxyZWFkeSBoYXZlIHRoaXMgZW50aXR5IGluIHN0b3JlXG4gICAgICBpZiAoaW5TdG9yZUVudGl0eSAmJiAoaW5TdG9yZU1ldGEgPSBzdG9yZUVudGl0eU1ldGFbc2NoZW1hS2V5XVtpZF0pKSB7XG4gICAgICAgIGVudGl0aWVzW3NjaGVtYUtleV1baWRdID0gc2NoZW1hLm1lcmdlV2l0aFN0b3JlXG4gICAgICAgICAgPyBzY2hlbWEubWVyZ2VXaXRoU3RvcmUoXG4gICAgICAgICAgICAgIGluU3RvcmVNZXRhLFxuICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICBpblN0b3JlRW50aXR5LFxuICAgICAgICAgICAgICBwcm9jZXNzZWRFbnRpdHksXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBtZXJnZVdpdGhTdG9yZShcbiAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICBpblN0b3JlTWV0YSxcbiAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgaW5TdG9yZUVudGl0eSxcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkRW50aXR5LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgc3RvcmVFbnRpdHlNZXRhW3NjaGVtYUtleV1baWRdID0gc2NoZW1hLm1lcmdlTWV0YVdpdGhTdG9yZVxuICAgICAgICAgID8gc2NoZW1hLm1lcmdlTWV0YVdpdGhTdG9yZShcbiAgICAgICAgICAgICAgaW5TdG9yZU1ldGEsXG4gICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgIGluU3RvcmVFbnRpdHksXG4gICAgICAgICAgICAgIHByb2Nlc3NlZEVudGl0eSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IG1lcmdlTWV0YVdpdGhTdG9yZShcbiAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICBpblN0b3JlTWV0YSxcbiAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgaW5TdG9yZUVudGl0eSxcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkRW50aXR5LFxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudGl0aWVzW3NjaGVtYUtleV1baWRdID0gcHJvY2Vzc2VkRW50aXR5O1xuICAgICAgICBzdG9yZUVudGl0eU1ldGFbc2NoZW1hS2V5XVtpZF0gPSB7XG4gICAgICAgICAgLy8gVE9ETyhicmVha2luZyk6IFJlbW92ZSBzY2hlbWEuZXhwaXJlc2F0XG4gICAgICAgICAgZXhwaXJlc0F0OiBzY2hlbWEuZXhwaXJlc0F0XG4gICAgICAgICAgICA/IHNjaGVtYS5leHBpcmVzQXQobWV0YSwgcHJvY2Vzc2VkRW50aXR5KVxuICAgICAgICAgICAgOiBtZXRhLmV4cGlyZXNBdCxcbiAgICAgICAgICBkYXRlOiBtZXRhLmRhdGUsXG4gICAgICAgICAgZmV0Y2hlZEF0OiBtZXRhLmZldGNoZWRBdCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgaW5kZXhcbiAgICBpZiAoc2NoZW1hLmluZGV4ZXMpIHtcbiAgICAgIGlmICghKHNjaGVtYUtleSBpbiBpbmRleGVzKSkge1xuICAgICAgICBpbmRleGVzW3NjaGVtYUtleV0gPSB7fTtcbiAgICAgICAgc3RvcmVJbmRleGVzW3NjaGVtYUtleV0gPSB7IC4uLnN0b3JlSW5kZXhlc1tzY2hlbWFLZXldIH07XG4gICAgICB9XG4gICAgICBoYW5kbGVJbmRleGVzKFxuICAgICAgICBpZCxcbiAgICAgICAgc2NoZW1hLmluZGV4ZXMsXG4gICAgICAgIGluZGV4ZXNbc2NoZW1hS2V5XSxcbiAgICAgICAgc3RvcmVJbmRleGVzW3NjaGVtYUtleV0sXG4gICAgICAgIGVudGl0aWVzW3NjaGVtYUtleV1baWRdLFxuICAgICAgICBzdG9yZUVudGl0aWVzW3NjaGVtYUtleV0sXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBzZXQgdGhpcyBhZnRlciBpbmRleCB1cGRhdGVzIHNvIHdlIGtub3cgd2hhdCBpbmRleGVzIHRvIHJlbW92ZSBmcm9tXG4gICAgc3RvcmVFbnRpdGllc1tzY2hlbWFLZXldW2lkXSA9IGVudGl0aWVzW3NjaGVtYUtleV1baWRdO1xuICB9O1xuXG5mdW5jdGlvbiBoYW5kbGVJbmRleGVzKFxuICBpZDogc3RyaW5nLFxuICBzY2hlbWFJbmRleGVzOiBzdHJpbmdbXSxcbiAgaW5kZXhlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgc3RvcmVJbmRleGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBlbnRpdHk6IGFueSxcbiAgc3RvcmVFbnRpdGllczogUmVjb3JkPHN0cmluZywgYW55Pixcbikge1xuICBmb3IgKGNvbnN0IGluZGV4IG9mIHNjaGVtYUluZGV4ZXMpIHtcbiAgICBpZiAoIShpbmRleCBpbiBpbmRleGVzKSkge1xuICAgICAgc3RvcmVJbmRleGVzW2luZGV4XSA9IGluZGV4ZXNbaW5kZXhdID0ge307XG4gICAgfVxuICAgIGNvbnN0IGluZGV4TWFwID0gaW5kZXhlc1tpbmRleF07XG4gICAgaWYgKHN0b3JlRW50aXRpZXNbaWRdKSB7XG4gICAgICBkZWxldGUgaW5kZXhNYXBbc3RvcmVFbnRpdGllc1tpZF1baW5kZXhdXTtcbiAgICB9XG4gICAgLy8gZW50aXR5IGFscmVhZHkgaW4gY2FjaGUgYnV0IHRoZSBpbmRleCBjaGFuZ2VkXG4gICAgaWYgKFxuICAgICAgc3RvcmVFbnRpdGllcyAmJlxuICAgICAgc3RvcmVFbnRpdGllc1tpZF0gJiZcbiAgICAgIHN0b3JlRW50aXRpZXNbaWRdW2luZGV4XSAhPT0gZW50aXR5W2luZGV4XVxuICAgICkge1xuICAgICAgaW5kZXhNYXBbc3RvcmVFbnRpdGllc1tpZF1baW5kZXhdXSA9IERFTEVURUQ7XG4gICAgfVxuICAgIGlmIChpbmRleCBpbiBlbnRpdHkpIHtcbiAgICAgIGluZGV4TWFwW2VudGl0eVtpbmRleF1dID0gaWQ7XG4gICAgfSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBlbHNlIGlmIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICkge1xuICAgICAgY29uc29sZS53YXJuKGBJbmRleCBub3QgZm91bmQgaW4gZW50aXR5LiBJbmRleGVzIG11c3QgYmUgdG9wLWxldmVsIG1lbWJlcnMgb2YgeW91ciBlbnRpdHkuXG5JbmRleDogJHtpbmRleH1cbkVudGl0eTogJHtKU09OLnN0cmluZ2lmeShlbnRpdHksIHVuZGVmaW5lZCwgMil9YCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRPRE8oYnJlYWtpbmcpOiByZW1vdmUgdGhpcyBpbiAxIGJyZWFraW5nIHJlbGVhc2VzXG4vKiogQGRlcHJlY2F0ZWQgdXNlIEVudGl0eS5tZXJnZVN0b3JlKCkgaW5zdGVhZCAqL1xuZnVuY3Rpb24gbWVyZ2VXaXRoU3RvcmUoXG4gIHNjaGVtYTogRW50aXR5SW50ZXJmYWNlPGFueT4sXG4gIGV4aXN0aW5nTWV0YToge1xuICAgIGRhdGU6IG51bWJlcjtcbiAgICBleHBpcmVzQXQ6IG51bWJlcjtcbiAgICBmZXRjaGVkQXQ6IG51bWJlcjtcbiAgfSxcbiAgaW5jb21pbmdNZXRhOiB7XG4gICAgZXhwaXJlc0F0OiBudW1iZXI7XG4gICAgZGF0ZTogbnVtYmVyO1xuICAgIGZldGNoZWRBdD86IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgfSxcbiAgZXhpc3Rpbmc6IGFueSxcbiAgaW5jb21pbmc6IGFueSxcbikge1xuICBjb25zdCB1c2VJbmNvbWluZyA9XG4gICAgLy8gdXNlSW5jb21pbmcgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggbGVnYWN5IG9wdGltaXN0aWNcbiAgICBzY2hlbWEudXNlSW5jb21pbmcgJiYgaW5jb21pbmdNZXRhLmZldGNoZWRBdFxuICAgICAgPyBzY2hlbWEudXNlSW5jb21pbmcoZXhpc3RpbmdNZXRhLCBpbmNvbWluZ01ldGEsIGV4aXN0aW5nLCBpbmNvbWluZylcbiAgICAgIDogZXhpc3RpbmdNZXRhLmRhdGUgPD0gaW5jb21pbmdNZXRhLmRhdGU7XG4gIGlmICh1c2VJbmNvbWluZykge1xuICAgIGlmICh0eXBlb2YgaW5jb21pbmcgIT09IHR5cGVvZiBleGlzdGluZykge1xuICAgICAgcmV0dXJuIGluY29taW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2NoZW1hLm1lcmdlKGV4aXN0aW5nLCBpbmNvbWluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxufVxuXG4vLyBUT0RPKGJyZWFraW5nKTogcmVtb3ZlIHRoaXMgaW4gMSBicmVha2luZyByZWxlYXNlc1xuLyoqIEBkZXByZWNhdGVkIHVzZSBFbnRpdHkubWVyZ2VNZXRhV2l0aFN0b3JlKCkgaW5zdGVhZCAqL1xuZnVuY3Rpb24gbWVyZ2VNZXRhV2l0aFN0b3JlKFxuICBzY2hlbWE6IGFueSxcbiAgZXhpc3RpbmdNZXRhOiB7XG4gICAgZGF0ZTogbnVtYmVyO1xuICAgIGV4cGlyZXNBdDogbnVtYmVyO1xuICAgIGZldGNoZWRBdDogbnVtYmVyO1xuICB9LFxuICBpbmNvbWluZ01ldGE6IHtcbiAgICBleHBpcmVzQXQ6IG51bWJlcjtcbiAgICBkYXRlOiBudW1iZXI7XG4gICAgZmV0Y2hlZEF0OiBudW1iZXI7XG4gIH0sXG4gIGV4aXN0aW5nOiBhbnksXG4gIGluY29taW5nOiBhbnksXG4pIHtcbiAgcmV0dXJuIHtcbiAgICBleHBpcmVzQXQ6IE1hdGgubWF4KFxuICAgICAgc2NoZW1hLmV4cGlyZXNBdFxuICAgICAgICA/IHNjaGVtYS5leHBpcmVzQXQoaW5jb21pbmdNZXRhLCBpbmNvbWluZylcbiAgICAgICAgOiBpbmNvbWluZ01ldGEuZXhwaXJlc0F0LFxuICAgICAgZXhpc3RpbmdNZXRhLmV4cGlyZXNBdCxcbiAgICApLFxuICAgIGRhdGU6IE1hdGgubWF4KGluY29taW5nTWV0YS5kYXRlLCBleGlzdGluZ01ldGEuZGF0ZSksXG4gICAgZmV0Y2hlZEF0OiBNYXRoLm1heChpbmNvbWluZ01ldGEuZmV0Y2hlZEF0LCBleGlzdGluZ01ldGEuZmV0Y2hlZEF0KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRTY2hlbWFUeXBlKHNjaGVtYTogU2NoZW1hKSB7XG4gIHJldHVybiBbJ29iamVjdCcsICdmdW5jdGlvbiddLmluY2x1ZGVzKHR5cGVvZiBzY2hlbWEpXG4gICAgPyAnb2JqZWN0J1xuICAgIDogdHlwZW9mIHNjaGVtYTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmV4cG9ydCBjb25zdCBub3JtYWxpemUgPSA8XG4gIFMgZXh0ZW5kcyBTY2hlbWEgPSBTY2hlbWEsXG4gIEUgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkPiA9IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAgUmVjb3JkPHN0cmluZywgYW55PlxuICA+LFxuICBSID0gTm9ybWFsaXplTnVsbGFibGU8Uz4sXG4+KFxuICBpbnB1dDogYW55LFxuICBzY2hlbWE/OiBTLFxuICBhcmdzOiBhbnlbXSA9IFtdLFxuICBzdG9yZUVudGl0aWVzOiBSZWFkb25seTxFPiA9IHt9IGFzIGFueSxcbiAgc3RvcmVJbmRleGVzOiBSZWFkb25seTxOb3JtYWxpemVkSW5kZXg+ID0ge30sXG4gIHN0b3JlRW50aXR5TWV0YToge1xuICAgIHJlYWRvbmx5IFtlbnRpdHlLZXk6IHN0cmluZ106IHtcbiAgICAgIHJlYWRvbmx5IFtwazogc3RyaW5nXToge1xuICAgICAgICByZWFkb25seSBkYXRlOiBudW1iZXI7XG4gICAgICAgIHJlYWRvbmx5IGV4cGlyZXNBdDogbnVtYmVyO1xuICAgICAgICByZWFkb25seSBmZXRjaGVkQXQ6IG51bWJlcjtcbiAgICAgIH07XG4gICAgfTtcbiAgfSA9IHt9LFxuICBtZXRhOiB7IGV4cGlyZXNBdDogbnVtYmVyOyBkYXRlOiBudW1iZXI7IGZldGNoZWRBdDogbnVtYmVyIH0gPSB7XG4gICAgZGF0ZTogRGF0ZS5ub3coKSxcbiAgICBleHBpcmVzQXQ6IEluZmluaXR5LFxuICAgIGZldGNoZWRBdDogMCxcbiAgfSxcbik6IE5vcm1hbGl6ZWRTY2hlbWE8RSwgUj4gPT4ge1xuICAvLyBubyBzY2hlbWEgbWVhbnMgd2UgZG9uJ3QgcHJvY2VzcyBhdCBhbGxcbiAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8IHNjaGVtYSA9PT0gbnVsbClcbiAgICByZXR1cm4ge1xuICAgICAgZW50aXRpZXM6IHN0b3JlRW50aXRpZXMsXG4gICAgICBpbmRleGVzOiBzdG9yZUluZGV4ZXMsXG4gICAgICByZXN1bHQ6IGlucHV0LFxuICAgICAgZW50aXR5TWV0YTogc3RvcmVFbnRpdHlNZXRhLFxuICAgIH07XG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGV4cGVjdGVkU2NoZW1hVHlwZShzY2hlbWEpO1xuICBpZiAoXG4gICAgaW5wdXQgPT09IG51bGwgfHxcbiAgICAodHlwZW9mIGlucHV0ICE9PSBzY2hlbWFUeXBlICYmXG4gICAgICAvLyB3ZSB3aWxsIGFsbG93IGEgRGVsZXRlIHNjaGVtYSB0byBiZSBhIHN0cmluZyBvciBvYmplY3RcbiAgICAgICEoXG4gICAgICAgIChzY2hlbWEgYXMgYW55KS5rZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoc2NoZW1hIGFzIGFueSkucGsgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnXG4gICAgICApKVxuICApIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCBwYXJzZVdvcmtzID0gKGlucHV0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIEpTT04ucGFyc2UoaW5wdXQpICE9PSAnc3RyaW5nJztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIHBhcnNlV29ya3MoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9ybWFsaXppbmcgYSBzdHJpbmcsIGJ1dCB0aGlzIGRvZXMgbWF0Y2ggc2NoZW1hLlxuXG5QYXJzaW5nIHRoaXMgaW5wdXQgc3RyaW5nIGFzIEpTT04gd29ya2VkLiBUaGlzIGxpa2VseSBpbmRpY2F0ZXMgZmV0Y2ggZnVuY3Rpb24gZGlkIG5vdCBwYXJzZVxudGhlIEpTT04uIEJ5IGRlZmF1bHQsIHRoaXMgb25seSBoYXBwZW5zIGlmIFwiY29udGVudC10eXBlXCIgaGVhZGVyIGluY2x1ZGVzIFwianNvblwiLlxuU2VlIGh0dHBzOi8vcmVzdGhvb2tzLmlvL3Jlc3QvYXBpL1Jlc3RFbmRwb2ludCNwYXJzZVJlc3BvbnNlIGZvciBtb3JlIGluZm9ybWF0aW9uXG5cbiAgU2NoZW1hOiAke0pTT04uc3RyaW5naWZ5KHNjaGVtYSwgdW5kZWZpbmVkLCAyKX1cbiAgSW5wdXQ6IFwiJHtpbnB1dH1cImApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBVbmV4cGVjdGVkIGlucHV0IGdpdmVuIHRvIG5vcm1hbGl6ZS4gRXhwZWN0ZWQgdHlwZSB0byBiZSBcIiR7c2NoZW1hVHlwZX1cIiwgZm91bmQgXCIke1xuICAgICAgICAgICAgaW5wdXQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgaW5wdXRcbiAgICAgICAgICB9XCIuXG5cbiAgICAgICAgICBTY2hlbWE6ICR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hLCB1bmRlZmluZWQsIDIpfVxuICAgICAgICAgIElucHV0OiBcIiR7aW5wdXR9XCJgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkIGlucHV0IGdpdmVuIHRvIG5vcm1hbGl6ZS4gRXhwZWN0ZWQgdHlwZSB0byBiZSBcIiR7c2NoZW1hVHlwZX1cIiwgZm91bmQgXCIke1xuICAgICAgICAgIGlucHV0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGlucHV0XG4gICAgICAgIH1cIi5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdFbnRpdGllczogRSA9IHt9IGFzIGFueTtcbiAgY29uc3QgbmV3SW5kZXhlczogTm9ybWFsaXplZEluZGV4ID0ge30gYXMgYW55O1xuICBjb25zdCBlbnRpdGllczogRSA9IHsgLi4uc3RvcmVFbnRpdGllcyB9IGFzIGFueTtcbiAgY29uc3QgaW5kZXhlczogTm9ybWFsaXplZEluZGV4ID0geyAuLi5zdG9yZUluZGV4ZXMgfTtcbiAgY29uc3QgZW50aXR5TWV0YTogYW55ID0geyAuLi5zdG9yZUVudGl0eU1ldGEgfTtcbiAgY29uc3QgYWRkRW50aXR5ID0gYWRkRW50aXRpZXMoXG4gICAgbmV3RW50aXRpZXMsXG4gICAgbmV3SW5kZXhlcyxcbiAgICBlbnRpdGllcyxcbiAgICBpbmRleGVzLFxuICAgIGVudGl0eU1ldGEsXG4gICAgbWV0YSxcbiAgKTtcbiAgY29uc3QgdmlzaXRlZEVudGl0aWVzID0ge307XG5cbiAgY29uc3QgcmVzdWx0ID0gdmlzaXQoXG4gICAgaW5wdXQsXG4gICAgaW5wdXQsXG4gICAgdW5kZWZpbmVkLFxuICAgIHNjaGVtYSxcbiAgICBhZGRFbnRpdHksXG4gICAgdmlzaXRlZEVudGl0aWVzLFxuICAgIHN0b3JlRW50aXRpZXMsXG4gICAgYXJncyxcbiAgKTtcbiAgcmV0dXJuIHsgZW50aXRpZXMsIGluZGV4ZXMsIHJlc3VsdCwgZW50aXR5TWV0YSB9O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQ0EsU0FBU0EsU0FBUyxJQUFJQyxjQUFjLFFBQVEsb0JBQW9CO0FBQ2hFLFNBQVNELFNBQVMsSUFBSUUsZUFBZSxRQUFRLHFCQUFxQjtBQUNsRSxTQUFTQyxPQUFPLFFBQVEsY0FBYztBQUd0QyxNQUFNQyxLQUFLLEdBQUdBLENBQ1pDLEtBQVUsRUFDVkMsTUFBVyxFQUNYQyxHQUFRLEVBQ1JDLE1BQVcsRUFDWEMsU0FJUyxFQUNUQyxlQUFvQixFQUNwQkMsYUFBa0IsRUFDbEJDLElBQVcsS0FDUjtFQUNILElBQUksQ0FBQ1AsS0FBSyxJQUFJLENBQUNHLE1BQU0sRUFBRTtJQUNyQixPQUFPSCxLQUFLO0VBQ2Q7RUFFQSxJQUFJRyxNQUFNLENBQUNSLFNBQVMsSUFBSSxPQUFPUSxNQUFN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