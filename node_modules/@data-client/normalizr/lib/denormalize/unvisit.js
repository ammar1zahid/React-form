import { INVALID } from './symbol.js';
import { isEntity } from '../isEntity.js';
import { denormalize as arrayDenormalize } from '../schemas/Array.js';
import { isImmutable } from '../schemas/ImmutableUtils.js';
import { denormalize as objectDenormalize } from '../schemas/Object.js';
function unvisitEntity(entityOrId, schema, args, unvisit, getEntity, cache) {
  const entity = typeof entityOrId === 'object' ? entityOrId : getEntity({
    key: schema.key,
    pk: entityOrId
  });
  if (typeof entity === 'symbol') {
    if (typeof schema.denormalizeOnly === 'function') {
      return schema.denormalizeOnly(entity, args, unvisit);
      // TODO(breaking): Change to this as breaking change once we only support newer entities
    } else if (entity.toString().includes('DELETED')) {
      return INVALID;
    }
  }
  if (typeof entity !== 'object' || entity === null) {
    return entity;
  }
  const pk =
  // normalize must always place a string, because pk() return value is string | undefined
  // therefore no need to check for numbers
  typeof entityOrId === 'string' ? entityOrId : schema.pk(isImmutable(entity) ? entity.toJS() : entity, undefined, undefined, args);

  // if we can't generate a working pk we cannot do cache lookups properly,
  // so simply denormalize without caching
  if (pk === undefined || pk === '' || pk === 'undefined') {
    return noCacheGetEntity(localCacheKey => unvisitEntityObject(entity, schema, unvisit, '', localCacheKey, args));
  }

  // last function computes if it is not in any caches
  return cache.getEntity(pk, schema, entity, localCacheKey => unvisitEntityObject(entity, schema, unvisit, pk, localCacheKey, args));
}
function noCacheGetEntity(computeValue) {
  const localCacheKey = {};
  computeValue(localCacheKey);
  return localCacheKey[''];
}
function unvisitEntityObject(entity, schema, unvisit, pk, localCacheKey, args) {
  let entityCopy, _, deleted;
  /* istanbul ignore else */
  if (schema.createIfValid) {
    entityCopy = localCacheKey[pk] = isImmutable(entity) ? schema.createIfValid(entity.toObject()) : schema.createIfValid(entity);
    // TODO(breaking): remove once old verions no longer supported
  } /* istanbul ignore next */else {
    entityCopy = entity;
    unvisit = withTrackedEntities(unvisit);
    unvisit.setLocal = entityCopy => localCacheKey[pk] = entityCopy;
  }
  if (entityCopy === undefined) {
    // undefined indicates we should suspense (perhaps failed validation)
    localCacheKey[pk] = INVALID;
  } else {
    if (typeof schema.denormalizeOnly === 'function') {
      localCacheKey[pk] = schema.denormalizeOnly(entityCopy, args, unvisit);
    } else {
      [localCacheKey[pk], _, deleted] = schema.denormalize(entityCopy, unvisit);
      if (deleted) localCacheKey[pk] = INVALID;
    }
  }
}

// TODO(breaking): remove once unused
/* istanbul ignore next */
function withTrackedEntities(unvisit) {
  // every time we nest, we want to unwrap back to the top.
  // this is due to only needed the next level of nested entities for lookup
  const originalUnvisit = unvisit.og || unvisit;
  const wrappedUnvisit = (input, schema) => originalUnvisit(input, schema);
  wrappedUnvisit.og = unvisit;
  return wrappedUnvisit;
}
const getUnvisit = (getEntity, cache, args) => {
  // TODO(breaking): This handles legacy schemas from 3.7 and below
  const unvisitAdapter = getUnvisitAdapter(unvisit);
  function unvisit(input, schema) {
    if (!schema) return input;
    if (input === null) {
      return input;
    }
    const hasDenormalize = typeof schema.denormalize === 'function' || typeof schema.denormalizeOnly === 'function';

    // deserialize fields (like Date)
    if (!hasDenormalize && typeof schema === 'function') {
      if (input instanceof schema) return input;
      if (input === undefined) return input;
      return new schema(input);
    }
    if (input === undefined) {
      var _schema$constructor;
      // TODO(breaking): Drop support for initial All version
      const isAll = ((_schema$constructor = schema.constructor) == null ? void 0 : _schema$constructor.name) === 'AllSchema';
      return isAll ? INVALID : undefined;
    }
    if (!hasDenormalize && typeof schema === 'object') {
      const method = Array.isArray(schema) ? arrayDenormalize : objectDenormalize;
      return method(schema, input, args, unvisit);
    }
    if (isEntity(schema)) {
      return unvisitEntity(input, schema, args, schema.denormalizeOnly ? unvisit : unvisitAdapter, getEntity, cache);
    }
    if (hasDenormalize) {
      if (schema.denormalizeOnly) {
        return schema.denormalizeOnly(input, args, unvisit);
      } else {
        return denormalizeLegacySchema(schema, input, unvisitAdapter);
      }
    }
    return input;
  }
  return (input, schema) => {
    // in the case where WeakMap cannot be used
    // this test ensures null is properly excluded from WeakMap
    const cachable = Object(input) === input && Object(schema) === schema;
    return cache.getResults(input, cachable, () => unvisit(input, schema));
  };
};
export default getUnvisit;
function denormalizeLegacySchema(schema, input, unvisitAdapter) {
  const [data, _, suspend] = schema.denormalize(input, unvisitAdapter);
  // TODO(breaking): Drop support for initial Query version
  // queryEndpoint schema only overrides 'denormalize' and 'infer'
  const isQuery = !Object.hasOwn(schema, 'normalize') && Object.hasOwn(schema, 'denormalize') && Object.hasOwn(schema, 'infer');
  return suspend && !isQuery ? INVALID : data;
}

// TODO(breaking): This handles legacy schemas from 3.7 and below
function getUnvisitAdapter(unvisit) {
  return function (input, schema) {
    var _schema$constructor2;
    const isAll = (schema == null ? void 0 : (_schema$constructor2 = schema.constructor) == null ? void 0 : _schema$constructor2.name) === 'AllSchema';
    const value = unvisit(input, schema);

    // TODO(breaking): Drop support for initial All version
    if (isAll) {
      // we swap 'found' and 'suspend' because the initial Query version used 'found' to determine whether
      // it should 'process'
      return [typeof value === 'symbol' ? undefined : value, typeof value !== 'symbol', false];
    }
    return [typeof value === 'symbol' ? undefined : value, true, typeof value === 'symbol'];
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJJTlZBTElEIiwiaXNFbnRpdHkiLCJkZW5vcm1hbGl6ZSIsImFycmF5RGVub3JtYWxpemUiLCJpc0ltbXV0YWJsZSIsIm9iamVjdERlbm9ybWFsaXplIiwidW52aXNpdEVudGl0eSIsImVudGl0eU9ySWQiLCJzY2hlbWEiLCJhcmdzIiwidW52aXNpdCIsImdldEVudGl0eSIsImNhY2hlIiwiZW50aXR5Iiwia2V5IiwicGsiLCJkZW5vcm1hbGl6ZU9ubHkiLCJ0b1N0cmluZyIsImluY2x1ZGVzIiwidG9KUyIsInVuZGVmaW5lZCIsIm5vQ2FjaGVHZXRFbnRpdHkiLCJsb2NhbENhY2hlS2V5IiwidW52aXNpdEVudGl0eU9iamVjdCIsImNvbXB1dGVWYWx1ZSIsImVudGl0eUNvcHkiLCJfIiwiZGVsZXRlZCIsImNyZWF0ZUlmVmFsaWQiLCJ0b09iamVjdCIsIndpdGhUcmFja2VkRW50aXRpZXMiLCJzZXRMb2NhbCIsIm9yaWdpbmFsVW52aXNpdCIsIm9nIiwid3JhcHBlZFVudmlzaXQiLCJpbnB1dCIsImdldFVudmlzaXQiLCJ1bnZpc2l0QWRhcHRlciIsImdldFVudmlzaXRBZGFwdGVyIiwiaGFzRGVub3JtYWxpemUiLCJfc2NoZW1hJGNvbnN0cnVjdG9yIiwiaXNBbGwiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJtZXRob2QiLCJBcnJheSIsImlzQXJyYXkiLCJkZW5vcm1hbGl6ZUxlZ2FjeVNjaGVtYSIsImNhY2hhYmxlIiwiT2JqZWN0IiwiZ2V0UmVzdWx0cyIsImRhdGEiLCJzdXNwZW5kIiwiaXNRdWVyeSIsImhhc093biIsIl9zY2hlbWEkY29uc3RydWN0b3IyIiwidmFsdWUiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvZGVub3JtYWxpemUvdW52aXNpdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSBDYWNoZSBmcm9tICcuL2NhY2hlLmpzJztcbmltcG9ydCB7IElOVkFMSUQgfSBmcm9tICcuL3N5bWJvbC5qcyc7XG5pbXBvcnQgdHlwZSB7IEVudGl0eUludGVyZmFjZSwgVW52aXNpdEZ1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJmYWNlLmpzJztcbmltcG9ydCB7IGlzRW50aXR5IH0gZnJvbSAnLi4vaXNFbnRpdHkuanMnO1xuaW1wb3J0IHsgZGVub3JtYWxpemUgYXMgYXJyYXlEZW5vcm1hbGl6ZSB9IGZyb20gJy4uL3NjaGVtYXMvQXJyYXkuanMnO1xuaW1wb3J0IHsgaXNJbW11dGFibGUgfSBmcm9tICcuLi9zY2hlbWFzL0ltbXV0YWJsZVV0aWxzLmpzJztcbmltcG9ydCB7IGRlbm9ybWFsaXplIGFzIG9iamVjdERlbm9ybWFsaXplIH0gZnJvbSAnLi4vc2NoZW1hcy9PYmplY3QuanMnO1xuaW1wb3J0IHR5cGUgeyBQYXRoIH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHsgdHlwZSBHZXRFbnRpdHkgfSBmcm9tICcuLi9XZWFrRW50aXR5TWFwLmpzJztcblxuZnVuY3Rpb24gdW52aXNpdEVudGl0eShcbiAgZW50aXR5T3JJZDogUmVjb3JkPHN0cmluZywgYW55PiB8IHN0cmluZyxcbiAgc2NoZW1hOiBFbnRpdHlJbnRlcmZhY2UsXG4gIGFyZ3M6IHJlYWRvbmx5IGFueVtdLFxuICB1bnZpc2l0OiBVbnZpc2l0RnVuY3Rpb24sXG4gIGdldEVudGl0eTogR2V0RW50aXR5LFxuICBjYWNoZTogQ2FjaGUsXG4pOiBvYmplY3QgfCB1bmRlZmluZWQgfCBzeW1ib2wge1xuICBjb25zdCBlbnRpdHkgPVxuICAgIHR5cGVvZiBlbnRpdHlPcklkID09PSAnb2JqZWN0J1xuICAgICAgPyBlbnRpdHlPcklkXG4gICAgICA6IGdldEVudGl0eSh7IGtleTogc2NoZW1hLmtleSwgcGs6IGVudGl0eU9ySWQgfSk7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnc3ltYm9sJykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hLmRlbm9ybWFsaXplT25seSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHNjaGVtYS5kZW5vcm1hbGl6ZU9ubHkoZW50aXR5LCBhcmdzLCB1bnZpc2l0KTtcbiAgICAgIC8vIFRPRE8oYnJlYWtpbmcpOiBDaGFuZ2UgdG8gdGhpcyBhcyBicmVha2luZyBjaGFuZ2Ugb25jZSB3ZSBvbmx5IHN1cHBvcnQgbmV3ZXIgZW50aXRpZXNcbiAgICB9IGVsc2UgaWYgKChlbnRpdHkgYXMgc3ltYm9sKS50b1N0cmluZygpLmluY2x1ZGVzKCdERUxFVEVEJykpIHtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgZW50aXR5ICE9PSAnb2JqZWN0JyB8fCBlbnRpdHkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZW50aXR5IGFzIGFueTtcbiAgfVxuXG4gIGNvbnN0IHBrID1cbiAgICAvLyBub3JtYWxpemUgbXVzdCBhbHdheXMgcGxhY2UgYSBzdHJpbmcsIGJlY2F1c2UgcGsoKSByZXR1cm4gdmFsdWUgaXMgc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgLy8gdGhlcmVmb3JlIG5vIG5lZWQgdG8gY2hlY2sgZm9yIG51bWJlcnNcbiAgICB0eXBlb2YgZW50aXR5T3JJZCA9PT0gJ3N0cmluZydcbiAgICAgID8gZW50aXR5T3JJZFxuICAgICAgOiBzY2hlbWEucGsoXG4gICAgICAgICAgaXNJbW11dGFibGUoZW50aXR5KSA/IChlbnRpdHkgYXMgYW55KS50b0pTKCkgOiBlbnRpdHksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBhcmdzLFxuICAgICAgICApO1xuXG4gIC8vIGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgd29ya2luZyBwayB3ZSBjYW5ub3QgZG8gY2FjaGUgbG9va3VwcyBwcm9wZXJseSxcbiAgLy8gc28gc2ltcGx5IGRlbm9ybWFsaXplIHdpdGhvdXQgY2FjaGluZ1xuICBpZiAocGsgPT09IHVuZGVmaW5lZCB8fCBwayA9PT0gJycgfHwgcGsgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5vQ2FjaGVHZXRFbnRpdHkobG9jYWxDYWNoZUtleSA9PlxuICAgICAgdW52aXNpdEVudGl0eU9iamVjdChlbnRpdHksIHNjaGVtYSwgdW52aXNpdCwgJycsIGxvY2FsQ2FjaGVLZXksIGFyZ3MpLFxuICAgICk7XG4gIH1cblxuICAvLyBsYXN0IGZ1bmN0aW9uIGNvbXB1dGVzIGlmIGl0IGlzIG5vdCBpbiBhbnkgY2FjaGVzXG4gIHJldHVybiBjYWNoZS5nZXRFbnRpdHkocGssIHNjaGVtYSwgZW50aXR5LCBsb2NhbENhY2hlS2V5ID0+XG4gICAgdW52aXNpdEVudGl0eU9iamVjdChlbnRpdHksIHNjaGVtYSwgdW52aXNpdCwgcGssIGxvY2FsQ2FjaGVLZXksIGFyZ3MpLFxuICApO1xufVxuXG5mdW5jdGlvbiBub0NhY2hlR2V0RW50aXR5KFxuICBjb21wdXRlVmFsdWU6IChsb2NhbENhY2hlS2V5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiB2b2lkLFxuKTogb2JqZWN0IHwgdW5kZWZpbmVkIHwgc3ltYm9sIHtcbiAgY29uc3QgbG9jYWxDYWNoZUtleSA9IHt9O1xuICBjb21wdXRlVmFsdWUobG9jYWxDYWNoZUtleSk7XG5cbiAgcmV0dXJuIGxvY2FsQ2FjaGVLZXlbJyddO1xufVxuXG5mdW5jdGlvbiB1bnZpc2l0RW50aXR5T2JqZWN0KFxuICBlbnRpdHk6IG9iamVjdCxcbiAgc2NoZW1hOiBFbnRpdHlJbnRlcmZhY2U8YW55PixcbiAgdW52aXNpdDogVW52aXNpdEZ1bmN0aW9uLFxuICBwazogc3RyaW5nLFxuICBsb2NhbENhY2hlS2V5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBhcmdzOiByZWFkb25seSBhbnlbXSxcbik6IHZvaWQge1xuICBsZXQgZW50aXR5Q29weTogYW55LCBfLCBkZWxldGVkO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoc2NoZW1hLmNyZWF0ZUlmVmFsaWQpIHtcbiAgICBlbnRpdHlDb3B5ID0gbG9jYWxDYWNoZUtleVtwa10gPSBpc0ltbXV0YWJsZShlbnRpdHkpXG4gICAgICA/IHNjaGVtYS5jcmVhdGVJZlZhbGlkKGVudGl0eS50b09iamVjdCgpKVxuICAgICAgOiBzY2hlbWEuY3JlYXRlSWZWYWxpZChlbnRpdHkpO1xuICAgIC8vIFRPRE8oYnJlYWtpbmcpOiByZW1vdmUgb25jZSBvbGQgdmVyaW9ucyBubyBsb25nZXIgc3VwcG9ydGVkXG4gIH0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZWxzZSB7XG4gICAgZW50aXR5Q29weSA9IGVudGl0eTtcbiAgICB1bnZpc2l0ID0gd2l0aFRyYWNrZWRFbnRpdGllcyh1bnZpc2l0KTtcbiAgICB1bnZpc2l0LnNldExvY2FsID0gZW50aXR5Q29weSA9PiAobG9jYWxDYWNoZUtleVtwa10gPSBlbnRpdHlDb3B5KTtcbiAgfVxuXG4gIGlmIChlbnRpdHlDb3B5ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyB1bmRlZmluZWQgaW5kaWNhdGVzIHdlIHNob3VsZCBzdXNwZW5zZSAocGVyaGFwcyBmYWlsZWQgdmFsaWRhdGlvbilcbiAgICBsb2NhbENhY2hlS2V5W3BrXSA9IElOVkFMSUQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEuZGVub3JtYWxpemVPbmx5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsb2NhbENhY2hlS2V5W3BrXSA9IHNjaGVtYS5kZW5vcm1hbGl6ZU9ubHkoZW50aXR5Q29weSwgYXJncywgdW52aXNpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtsb2NhbENhY2hlS2V5W3BrXSwgXywgZGVsZXRlZF0gPSAoc2NoZW1hIGFzIGFueSkuZGVub3JtYWxpemUoXG4gICAgICAgIGVudGl0eUNvcHksXG4gICAgICAgIHVudmlzaXQsXG4gICAgICApO1xuICAgICAgaWYgKGRlbGV0ZWQpIGxvY2FsQ2FjaGVLZXlbcGtdID0gSU5WQUxJRDtcbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETyhicmVha2luZyk6IHJlbW92ZSBvbmNlIHVudXNlZFxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHdpdGhUcmFja2VkRW50aXRpZXModW52aXNpdDogVW52aXNpdEZ1bmN0aW9uKTogVW52aXNpdEZ1bmN0aW9uIHtcbiAgLy8gZXZlcnkgdGltZSB3ZSBuZXN0LCB3ZSB3YW50IHRvIHVud3JhcCBiYWNrIHRvIHRoZSB0b3AuXG4gIC8vIHRoaXMgaXMgZHVlIHRvIG9ubHkgbmVlZGVkIHRoZSBuZXh0IGxldmVsIG9mIG5lc3RlZCBlbnRpdGllcyBmb3IgbG9va3VwXG4gIGNvbnN0IG9yaWdpbmFsVW52aXNpdCA9IHVudmlzaXQub2cgfHwgdW52aXNpdDtcbiAgY29uc3Qgd3JhcHBlZFVudmlzaXQgPSAoaW5wdXQ6IGFueSwgc2NoZW1hOiBhbnkpID0+XG4gICAgb3JpZ2luYWxVbnZpc2l0KGlucHV0LCBzY2hlbWEpO1xuICB3cmFwcGVkVW52aXNpdC5vZyA9IHVudmlzaXQ7XG4gIHJldHVybiB3cmFwcGVkVW52aXNpdDtcbn1cblxuY29uc3QgZ2V0VW52aXNpdCA9IChcbiAgZ2V0RW50aXR5OiBHZXRFbnRpdHksXG4gIGNhY2hlOiBDYWNoZSxcbiAgYXJnczogcmVhZG9ubHkgYW55W10sXG4pID0+IHtcbiAgLy8gVE9ETyhicmVha2luZyk6IFRoaXMgaGFuZGxlcyBsZWdhY3kgc2NoZW1hcyBmcm9tIDMuNyBhbmQgYmVsb3dcbiAgY29uc3QgdW52aXNpdEFkYXB0ZXIgPSBnZXRVbnZpc2l0QWRhcHRlcih1bnZpc2l0KTtcblxuICBmdW5jdGlvbiB1bnZpc2l0KGlucHV0OiBhbnksIHNjaGVtYTogYW55KTogYW55IHtcbiAgICBpZiAoIXNjaGVtYSkgcmV0dXJuIGlucHV0O1xuXG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzRGVub3JtYWxpemUgPVxuICAgICAgdHlwZW9mIHNjaGVtYS5kZW5vcm1hbGl6ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIHNjaGVtYS5kZW5vcm1hbGl6ZU9ubHkgPT09ICdmdW5jdGlvbic7XG5cbiAgICAvLyBkZXNlcmlhbGl6ZSBmaWVsZHMgKGxpa2UgRGF0ZSlcbiAgICBpZiAoIWhhc0Rlbm9ybWFsaXplICYmIHR5cGVvZiBzY2hlbWEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIHNjaGVtYSkgcmV0dXJuIGlucHV0O1xuICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHJldHVybiBpbnB1dDtcbiAgICAgIHJldHVybiBuZXcgc2NoZW1hKGlucHV0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVE9ETyhicmVha2luZyk6IERyb3Agc3VwcG9ydCBmb3IgaW5pdGlhbCBBbGwgdmVyc2lvblxuICAgICAgY29uc3QgaXNBbGwgPSBzY2hlbWEuY29uc3RydWN0b3I/Lm5hbWUgPT09ICdBbGxTY2hlbWEnO1xuXG4gICAgICByZXR1cm4gaXNBbGwgPyBJTlZBTElEIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghaGFzRGVub3JtYWxpemUgJiYgdHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICA/IGFycmF5RGVub3JtYWxpemVcbiAgICAgICAgOiBvYmplY3REZW5vcm1hbGl6ZTtcbiAgICAgIHJldHVybiBtZXRob2Qoc2NoZW1hLCBpbnB1dCwgYXJncywgdW52aXNpdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRW50aXR5KHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiB1bnZpc2l0RW50aXR5KFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBhcmdzLFxuICAgICAgICBzY2hlbWEuZGVub3JtYWxpemVPbmx5ID8gdW52aXNpdCA6IHVudmlzaXRBZGFwdGVyLFxuICAgICAgICBnZXRFbnRpdHksXG4gICAgICAgIGNhY2hlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzRGVub3JtYWxpemUpIHtcbiAgICAgIGlmIChzY2hlbWEuZGVub3JtYWxpemVPbmx5KSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZGVub3JtYWxpemVPbmx5KGlucHV0LCBhcmdzLCB1bnZpc2l0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZW5vcm1hbGl6ZUxlZ2FjeVNjaGVtYShzY2hlbWEsIGlucHV0LCB1bnZpc2l0QWRhcHRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgcmV0dXJuIChpbnB1dDogYW55LCBzY2hlbWE6IGFueSk6IHsgZGF0YTogYW55OyBwYXRoczogUGF0aFtdIH0gPT4ge1xuICAgIC8vIGluIHRoZSBjYXNlIHdoZXJlIFdlYWtNYXAgY2Fubm90IGJlIHVzZWRcbiAgICAvLyB0aGlzIHRlc3QgZW5zdXJlcyBudWxsIGlzIHByb3Blcmx5IGV4Y2x1ZGVkIGZyb20gV2Vha01hcFxuICAgIGNvbnN0IGNhY2hhYmxlID0gT2JqZWN0KGlucHV0KSA9PT0gaW5wdXQgJiYgT2JqZWN0KHNjaGVtYSkgPT09IHNjaGVtYTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0UmVzdWx0cyhpbnB1dCwgY2FjaGFibGUsICgpID0+IHVudmlzaXQoaW5wdXQsIHNjaGVtYSkpO1xuICB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IGdldFVudmlzaXQ7XG5cbmZ1bmN0aW9uIGRlbm9ybWFsaXplTGVnYWN5U2NoZW1hKFxuICBzY2hlbWE6IGFueSxcbiAgaW5wdXQ6IGFueSxcbiAgdW52aXNpdEFkYXB0ZXI6IChpbnB1dDogYW55LCBzY2hlbWE6IGFueSkgPT4gW2FueSwgYm9vbGVhbiwgYm9vbGVhbl0sXG4pIHtcbiAgY29uc3QgW2RhdGEsIF8sIHN1c3BlbmRdID0gc2NoZW1hLmRlbm9ybWFsaXplKGlucHV0LCB1bnZpc2l0QWRhcHRlcik7XG4gIC8vIFRPRE8oYnJlYWtpbmcpOiBEcm9wIHN1cHBvcnQgZm9yIGluaXRpYWwgUXVlcnkgdmVyc2lvblxuICAvLyBxdWVyeUVuZHBvaW50IHNjaGVtYSBvbmx5IG92ZXJyaWRlcyAnZGVub3JtYWxpemUnIGFuZCAnaW5mZXInXG4gIGNvbnN0IGlzUXVlcnkgPVxuICAgICFPYmplY3QuaGFzT3duKHNjaGVtYSwgJ25vcm1hbGl6ZScpICYmXG4gICAgT2JqZWN0Lmhhc093bihzY2hlbWEsICdkZW5vcm1hbGl6ZScpICYmXG4gICAgT2JqZWN0Lmhhc093bihzY2hlbWEsICdpbmZlcicpO1xuICByZXR1cm4gc3VzcGVuZCAmJiAhaXNRdWVyeSA/IElOVkFMSUQgOiBkYXRhO1xufVxuXG4vLyBUT0RPKGJyZWFraW5nKTogVGhpcyBoYW5kbGVzIGxlZ2FjeSBzY2hlbWFzIGZyb20gMy43IGFuZCBiZWxvd1xuZnVuY3Rpb24gZ2V0VW52aXNpdEFkYXB0ZXIodW52aXNpdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGlucHV0OiBhbnksIHNjaGVtYTogYW55KTogW2FueSwgYm9vbGVhbiwgYm9vbGVhbl0ge1xuICAgIGNvbnN0IGlzQWxsID0gc2NoZW1hPy5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0FsbFNjaGVtYSc7XG4gICAgY29uc3QgdmFsdWUgPSB1bnZpc2l0KGlucHV0LCBzY2hlbWEpO1xuXG4gICAgLy8gVE9ETyhicmVha2luZyk6IERyb3Agc3VwcG9ydCBmb3IgaW5pdGlhbCBBbGwgdmVyc2lvblxuICAgIGlmIChpc0FsbCkge1xuICAgICAgLy8gd2Ugc3dhcCAnZm91bmQnIGFuZCAnc3VzcGVuZCcgYmVjYXVzZSB0aGUgaW5pdGlhbCBRdWVyeSB2ZXJzaW9uIHVzZWQgJ2ZvdW5kJyB0byBkZXRlcm1pbmUgd2hldGhlclxuICAgICAgLy8gaXQgc2hvdWxkICdwcm9jZXNzJ1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyA/IHVuZGVmaW5lZCA6IHZhbHVlLFxuICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnLFxuICAgICAgICBmYWxzZSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnID8gdW5kZWZpbmVkIDogdmFsdWUsXG4gICAgICB0cnVlLFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyxcbiAgICBdO1xuICB9O1xufVxuIl0sIm1hcHBpbmdzIjoiQUFDQSxTQUFTQSxPQUFPLFFBQVEsYUFBYTtBQUVyQyxTQUFTQyxRQUFRLFFBQVEsZ0JBQWdCO0FBQ3pDLFNBQVNDLFdBQVcsSUFBSUMsZ0JBQWdCLFFBQVEscUJBQXFCO0FBQ3JFLFNBQVNDLFdBQVcsUUFBUSw4QkFBOEI7QUFDMUQsU0FBU0YsV0FBVyxJQUFJRyxpQkFBaUIsUUFBUSxzQkFBc0I7QUFJdkUsU0FBU0MsYUFBYUEsQ0FDcEJDLFVBQXdDLEVBQ3hDQyxNQUF1QixFQUN2QkMsSUFBb0IsRUFDcEJDLE9BQXdCLEVBQ3hCQyxTQUFvQixFQUNwQkMsS0FBWSxFQUNpQjtFQUM3QixNQUFNQyxNQUFNLEdBQ1YsT0FBT04sVUFBVSxLQUFLLFFBQVEsR0FDMUJBLFVBQVUsR0FDVkksU0FBUyxDQUFDO0lBQUVHLEdBQUcsRUFBRU4sTUFBTSxDQUFDTSxHQUFHO0lBQUVDLEVBQUUsRUFBRVI7RUFBVyxDQUFDLENBQUM7RUFDcEQsSUFBSSxPQUFPTSxNQUFNLEtBQUssUUFBUSxFQUFFO0lBQzlCLElBQUksT0FBT0wsTUFBTSxDQUFDUSxlQUFlLEtBQUssVUFBVSxFQUFFO01BQ2hELE9BQU9SLE1BQU0sQ0FBQ1EsZUFBZSxDQUFDSCxNQUFNLEVBQUVKLElBQUksRUFBRUMsT0FBTyxDQUFDO01BQ3BEO0lBQ0YsQ0FBQyxNQUFNLElBQUtHLE1BQU0sQ0FBWUksUUFBUSxDQUFDLENBQUMsQ0FBQ0MsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO01BQzVELE9BQU9sQixPQUFPO0lBQ2hCO0VBQ0Y7RUFFQSxJQUFJLE9BQU9hLE1BQU0sS0FBSyxRQUFRLElBQUlBLE1BQU0sS0FBSyxJQUFJLEVB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