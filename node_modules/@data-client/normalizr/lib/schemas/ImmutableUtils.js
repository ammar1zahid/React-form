/**
 * Helpers to enable Immutable compatibility *without* bringing in
 * the 'immutable' package as a dependency.
 */

import { INVALID } from '../denormalize/symbol.js';

/**
 * Check if an object is immutable by checking if it has a key specific
 * to the immutable library.
 *
 * @param  {any} object
 * @return {bool}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function isImmutable(object) {
  return !!(typeof object.hasOwnProperty === 'function' && (Object.hasOwnProperty.call(object, '__ownerID') ||
  // Immutable.Map
  object._map && Object.hasOwnProperty.call(object._map, '__ownerID'))); // Immutable.Record
}

/**
 * Denormalize an immutable entity.
 *
 * @param  {Schema} schema
 * @param  {Immutable.Map|Immutable.Record} input
 * @param  {function} unvisit
 * @param  {function} getDenormalizedEntity
 * @return {Immutable.Map|Immutable.Record}
 */
export function denormalizeImmutable(schema, input, args, unvisit) {
  let deleted = false;
  const obj = Object.keys(schema).reduce((object, key) => {
    // Immutable maps cast keys to strings on write so we need to ensure
    // we're accessing them using string keys.
    const stringKey = `${key}`;
    const item = unvisit(object.get(stringKey), schema[stringKey]);
    if (typeof item === 'symbol') {
      deleted = true;
    }
    if (object.has(stringKey)) {
      return object.set(stringKey, item);
    } else {
      return object;
    }
  }, input);
  return deleted ? INVALID : obj;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJJTlZBTElEIiwiaXNJbW11dGFibGUiLCJvYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsImNhbGwiLCJfbWFwIiwiZGVub3JtYWxpemVJbW11dGFibGUiLCJzY2hlbWEiLCJpbnB1dCIsImFyZ3MiLCJ1bnZpc2l0IiwiZGVsZXRlZCIsIm9iaiIsImtleXMiLCJyZWR1Y2UiLCJrZXkiLCJzdHJpbmdLZXkiLCJpdGVtIiwiZ2V0IiwiaGFzIiwic2V0Il0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NjaGVtYXMvSW1tdXRhYmxlVXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzIHRvIGVuYWJsZSBJbW11dGFibGUgY29tcGF0aWJpbGl0eSAqd2l0aG91dCogYnJpbmdpbmcgaW5cbiAqIHRoZSAnaW1tdXRhYmxlJyBwYWNrYWdlIGFzIGEgZGVwZW5kZW5jeS5cbiAqL1xuXG5pbXBvcnQgeyBJTlZBTElEIH0gZnJvbSAnLi4vZGVub3JtYWxpemUvc3ltYm9sLmpzJztcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgaW1tdXRhYmxlIGJ5IGNoZWNraW5nIGlmIGl0IGhhcyBhIGtleSBzcGVjaWZpY1xuICogdG8gdGhlIGltbXV0YWJsZSBsaWJyYXJ5LlxuICpcbiAqIEBwYXJhbSAge2FueX0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW1tdXRhYmxlKG9iamVjdDoge30pOiBvYmplY3QgaXMge1xuICBnZXQoazogc3RyaW5nKTogYW55O1xuICBbazogc3RyaW5nXTogYW55O1xufSB7XG4gIHJldHVybiAhIShcbiAgICB0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmXG4gICAgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fb3duZXJJRCcpIHx8IC8vIEltbXV0YWJsZS5NYXBcbiAgICAgICgob2JqZWN0IGFzIGFueSkuX21hcCAmJlxuICAgICAgICBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCgob2JqZWN0IGFzIGFueSkuX21hcCwgJ19fb3duZXJJRCcpKSlcbiAgKTsgLy8gSW1tdXRhYmxlLlJlY29yZFxufVxuXG4vKipcbiAqIERlbm9ybWFsaXplIGFuIGltbXV0YWJsZSBlbnRpdHkuXG4gKlxuICogQHBhcmFtICB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSAge0ltbXV0YWJsZS5NYXB8SW1tdXRhYmxlLlJlY29yZH0gaW5wdXRcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1bnZpc2l0XG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZ2V0RGVub3JtYWxpemVkRW50aXR5XG4gKiBAcmV0dXJuIHtJbW11dGFibGUuTWFwfEltbXV0YWJsZS5SZWNvcmR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZW5vcm1hbGl6ZUltbXV0YWJsZShcbiAgc2NoZW1hOiBhbnksXG4gIGlucHV0OiBhbnksXG4gIGFyZ3M6IHJlYWRvbmx5IGFueVtdLFxuICB1bnZpc2l0OiBhbnksXG4pOiBhbnkge1xuICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuICBjb25zdCBvYmogPSBPYmplY3Qua2V5cyhzY2hlbWEpLnJlZHVjZSgob2JqZWN0LCBrZXkpID0+IHtcbiAgICAvLyBJbW11dGFibGUgbWFwcyBjYXN0IGtleXMgdG8gc3RyaW5ncyBvbiB3cml0ZSBzbyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgIC8vIHdlJ3JlIGFjY2Vzc2luZyB0aGVtIHVzaW5nIHN0cmluZyBrZXlzLlxuICAgIGNvbnN0IHN0cmluZ0tleSA9IGAke2tleX1gO1xuXG4gICAgY29uc3QgaXRlbSA9IHVudmlzaXQob2JqZWN0LmdldChzdHJpbmdLZXkpLCBzY2hlbWFbc3RyaW5nS2V5XSk7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3ltYm9sJykge1xuICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvYmplY3QuaGFzKHN0cmluZ0tleSkpIHtcbiAgICAgIHJldHVybiBvYmplY3Quc2V0KHN0cmluZ0tleSwgaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9LCBpbnB1dCk7XG4gIHJldHVybiBkZWxldGVkID8gSU5WQUxJRCA6IG9iajtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU0EsT0FBTyxRQUFRLDBCQUEwQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sU0FBU0MsV0FBV0EsQ0FBQ0MsTUFBVSxFQUdwQztFQUNBLE9BQU8sQ0FBQyxFQUNOLE9BQU9BLE1BQU0sQ0FBQ0MsY0FBYyxLQUFLLFVBQVUsS0FDMUNDLE1BQU0sQ0FBQ0QsY0FBYyxDQUFDRSxJQUFJLENBQUNILE1BQU0sRUFBRSxXQUFXLENBQUM7RUFBSTtFQUNoREEsTUFBTSxDQUFTSSxJQUFJLElBQ25CRixNQUFNLENBQUNELGNBQWMsQ0FBQ0UsSUFBSSxDQUFFSCxNQUFNLENBQVNJLElBQUksRUFBRSxXQUFXLENBQUUsQ0FBQyxDQUNwRSxDQUFDLENBQUM7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVNDLG9CQUFvQkEsQ0FDbENDLE1BQVcsRUFDWEMsS0FBVSxFQUNWQyxJQUFvQixFQUNwQkMsT0FBWSxFQUNQO0VBQ0wsSUFBSUMsT0FBTyxHQUFHLEtBQUs7RUFDbkIsTUFBTUMsR0FBRyxHQUFHVCxNQUFNLENBQUNVLElBQUksQ0FBQ04sTUFBTSxDQUFDLENBQUNPLE1BQU0sQ0FBQyxDQUFDYixNQUFNLEVBQUVjLEdBQUcsS0FBSztJQUN0RDtJQUNBO0lBQ0EsTUFBTUMsU0FBUyxHQUFJLEdBQUVELEdBQUksRUFBQztJQUUxQixNQUFNRSxJQUFJLEdBQUdQLE9BQU8sQ0FBQ1QsTUFBTSxDQUFDaUIsR0FBRyxDQUFDRixTQUFTLENBQUMsRUFBRVQsTUFBTSxDQUFDUyxTQUFTLENBQUMsQ0FBQztJQUM5RCxJQUFJLE9BQU9DLElBQUksS0FBSyxRQUFRLEVBQUU7TUFDNUJOLE9BQU8sR0FBRyxJQUFJO0lBQ2hCO0lBQ0EsSUFBSVYsTUFBTSxDQUFDa0IsR0FBRyxDQUFDSCxTQUFTLENBQUMsRUFBRTtNQUN6QixPQUFPZixNQUFNLENBQUNtQixHQUFHLENBQUNKLFNBQVMsRUFBRUMsSUFBSSxDQUFDO0lBQ3BDLENBQUMsTUFBTTtNQUNMLE9BQU9oQixNQUFNO0lBQ2Y7RUFDRixDQUFDLEVBQUVPLEtBQUssQ0FBQztFQUNULE9BQU9HLE9BQU8sR0FBR1osT0FBTyxHQUFHYSxHQUFHO0FBQ2hDIn0=